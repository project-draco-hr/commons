def _generate_individual(self, classpath, targets, create_jvmdoc_command):
    jobs = {}
    for target in targets:
        gendir = self._gendir(target)
        command = create_jvmdoc_command(classpath, gendir, target)
        if command:
            jobs[gendir] = (target, command)
    if jobs:
        with contextlib.closing(multiprocessing.Pool(processes=min(len(jobs), multiprocessing.cpu_count()))) as pool:
            futures = []
            for (gendir, (target, command)) in jobs.items():
                futures.append(pool.apply_async(create_jvmdoc, args=(command, gendir)))
            for future in futures:
                (result, gendir) = future.get()
                (target, command) = jobs[gendir]
                if (result != 0):
                    message = ('Failed to process %s for %s [%d]: %s' % (self._jvmdoc.tool_name, target, result, command))
                    if self.ignore_failure:
                        self.context.log.warn(message)
                    else:
                        raise TaskError(message)
