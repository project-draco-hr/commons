def ivy_resolve(self, targets, java_runner=None, ivy_args=None):
    from twitter.pants.tasks.ivy_utils import IvyUtils
    from twitter.pants.binary_util import runjava_indivisible
    java_runner = (java_runner or runjava_indivisible)
    ivy_args = (ivy_args or [])
    targets = set(targets)
    if (not targets):
        return []
    work_dir = self.context.config.get('ivy-resolve', 'workdir')
    confs = self.context.config.getlist('ivy-resolve', 'confs')
    with self.invalidated(targets, only_buildfiles=True, invalidate_dependents=True) as invalidation_check:
        global_vts = VersionedTargetSet.from_versioned_targets(invalidation_check.all_vts)
        target_workdir = os.path.join(work_dir, global_vts.cache_key.hash)
        target_classpath_file = os.path.join(target_workdir, 'classpath')
        if (invalidation_check.invalid_vts or (not os.path.exists(target_classpath_file))):
            ivy_utils = IvyUtils(config=self.context.config, options=self.context.options, log=self.context.log)
            args = (((['-cachepath', target_classpath_file] + ['-confs']) + confs) + ivy_args)
            ivy_utils.exec_ivy(target_workdir=target_workdir, targets=targets, args=args, runjava=java_runner, workunit_factory=self.context.new_workunit)
            if (not os.path.exists(target_classpath_file)):
                raise TaskError(('Ivy failed to create classpath file at %s %s' % target_classpath_file))
            if (self.get_artifact_cache() and self.context.options.write_to_artifact_cache):
                self.update_artifact_cache([(global_vts, [target_classpath_file])])
    with IvyUtils.cachepath(target_classpath_file) as classpath:
        stripped_classpath = [path.strip() for path in classpath]
        return [path for path in stripped_classpath if IvyUtils.is_mappable_artifact(path)]
