def ivy_resolve(self, targets, java_runner=None, symlink_ivyxml=False, silent=False, workunit_name=None, workunit_labels=None):
    java_runner = (java_runner or runjava_indivisible)
    targets = set(targets)
    if (not targets):
        return []
    work_dir = self.context.config.get('ivy-resolve', 'workdir')
    confs = self.context.config.getlist('ivy-resolve', 'confs')
    with self.invalidated(targets, only_buildfiles=True, invalidate_dependents=True, silent=silent) as invalidation_check:
        global_vts = VersionedTargetSet.from_versioned_targets(invalidation_check.all_vts)
        target_workdir = os.path.join(work_dir, global_vts.cache_key.hash)
        target_classpath_file = os.path.join(target_workdir, 'classpath')
        raw_target_classpath_file = (target_classpath_file + '.raw')
        raw_target_classpath_file_tmp = (raw_target_classpath_file + '.tmp')
        symlink_dir = os.path.join(target_workdir, 'jars')
        if (invalidation_check.invalid_vts or (not os.path.exists(raw_target_classpath_file))):
            ivy_utils = IvyUtils(config=self.context.config, options=self.context.options, log=self.context.log)
            args = ((['-cachepath', raw_target_classpath_file_tmp] + ['-confs']) + confs)

            def exec_ivy():
                ivy_utils.exec_ivy(target_workdir=target_workdir, targets=targets, args=args, runjava=java_runner, workunit_name='ivy', workunit_factory=self.context.new_workunit, symlink_ivyxml=symlink_ivyxml)
            if workunit_name:
                with self.context.new_workunit(name=workunit_name, labels=(workunit_labels or [])):
                    exec_ivy()
            else:
                exec_ivy()
            if (not os.path.exists(raw_target_classpath_file_tmp)):
                raise TaskError(('Ivy failed to create classpath file at %s' % raw_target_classpath_file_tmp))
            shutil.move(raw_target_classpath_file_tmp, raw_target_classpath_file)
            if self.artifact_cache_writes_enabled():
                self.update_artifact_cache([(global_vts, [raw_target_classpath_file])])
    symlink_map = IvyUtils.symlink_cachepath(raw_target_classpath_file, symlink_dir, target_classpath_file)
    with Task.symlink_map_lock:
        all_symlinks_map = (self.context.products.get_data('symlink_map') or defaultdict(list))
        for (path, symlink) in symlink_map.items():
            all_symlinks_map[path].append(symlink)
        self.context.products.set_data('symlink_map', all_symlinks_map)
    with IvyUtils.cachepath(target_classpath_file) as classpath:
        stripped_classpath = [path.strip() for path in classpath]
        return [path for path in stripped_classpath if IvyUtils.is_mappable_artifact(path)]
