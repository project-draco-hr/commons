@contextmanager
def invalidated(self, targets, only_buildfiles=False, invalidate_dependents=False, partition_size_hint=sys.maxint, silent=False):
    "Checks targets for invalidation, first checking the artifact cache.\n    Subclasses call this to figure out what to work on.\n\n    targets:               The targets to check for changes.\n    only_buildfiles:       If True, then only the target's BUILD files are checked for changes, not\n                           its sources.\n    invalidate_dependents: If True then any targets depending on changed targets are invalidated.\n    partition_size_hint:   Each VersionedTargetSet in the yielded list will represent targets\n                           containing roughly this number of source files, if possible. Set to\n                           sys.maxint for a single VersionedTargetSet. Set to 0 for one\n                           VersionedTargetSet per target. It is up to the caller to do the right\n                           thing with whatever partitioning it asks for.\n\n    Yields an InvalidationCheck object reflecting the (partitioned) targets.\n\n    If no exceptions are thrown by work in the block, the build cache is updated for the targets.\n    Note: the artifact cache is not updated. That must be done manually.\n    "
    extra_data = []
    extra_data.append(self.invalidate_for())
    for f in self.invalidate_for_files():
        extra_data.append(hash_file(f))
    cache_manager = CacheManager(self._cache_key_generator, self._build_invalidator_dir, invalidate_dependents, extra_data, only_externaldeps=only_buildfiles)
    invalidation_check = cache_manager.check(targets, partition_size_hint)
    if (invalidation_check.invalid_vts and self.artifact_cache_reads_enabled()):
        with self.context.new_workunit('cache'):
            (cached_vts, uncached_vts) = self.check_artifact_cache(self.check_artifact_cache_for(invalidation_check))
        if cached_vts:
            cached_targets = [vt.target for vt in cached_vts]
            for t in cached_targets:
                self.context.run_tracker.artifact_cache_stats.add_hit('default', t)
            if (not silent):
                self._report_targets('Using cached artifacts for ', cached_targets, '.')
        if uncached_vts:
            uncached_targets = [vt.target for vt in uncached_vts]
            for t in uncached_targets:
                self.context.run_tracker.artifact_cache_stats.add_miss('default', t)
            if (not silent):
                self._report_targets('No cached artifacts for ', uncached_targets, '.')
        invalidation_check = InvalidationCheck(invalidation_check.all_vts, uncached_vts, partition_size_hint)
    if (not silent):
        targets = []
        sources = []
        num_invalid_partitions = len(invalidation_check.invalid_vts_partitioned)
        for vt in invalidation_check.invalid_vts_partitioned:
            targets.extend(vt.targets)
            sources.extend(vt.cache_key.sources)
        if len(targets):
            msg_elements = ['Invalidated ', items_to_report_element([t.address.reference() for t in targets], 'target')]
            if (len(sources) > 0):
                msg_elements.append(' containing ')
                msg_elements.append(items_to_report_element(sources, 'source file'))
            if (num_invalid_partitions > 1):
                msg_elements.append((' in %d target partitions' % num_invalid_partitions))
            msg_elements.append('.')
            self.context.log.info(*msg_elements)
    yield invalidation_check
    if (not self.dry_run):
        for vt in invalidation_check.invalid_vts:
            vt.update()
