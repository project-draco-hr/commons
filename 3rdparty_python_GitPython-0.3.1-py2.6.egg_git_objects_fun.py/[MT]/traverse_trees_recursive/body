def traverse_trees_recursive(odb, tree_shas, path_prefix):
    "\n\t:return: list with entries according to the given binary tree-shas. \n\t\tThe result is encoded in a list\n\t\tof n tuple|None per blob/commit, (n == len(tree_shas)), where \n\t\t* [0] == 20 byte sha\n\t\t* [1] == mode as int\n\t\t* [2] == path relative to working tree root\n\t\tThe entry tuple is None if the respective blob/commit did not \n\t\texist in the given tree.\n\t:param tree_shas: iterable of shas pointing to trees. All trees must \n\t\tbe on the same level. A tree-sha may be None in which case None\n\t:param path_prefix: a prefix to be added to the returned paths on this level, \n\t\tset it '' for the first iteration\n\t:note: The ordering of the returned items will be partially lost"
    trees_data = list()
    nt = len(tree_shas)
    for tree_sha in tree_shas:
        if (tree_sha is None):
            data = list()
        else:
            data = tree_entries_from_data(odb.stream(tree_sha).read())
        trees_data.append(data)
    out = list()
    out_append = out.append
    for (ti, tree_data) in enumerate(trees_data):
        for (ii, item) in enumerate(tree_data):
            if (not item):
                continue
            entries = [None for n in range(nt)]
            entries[ti] = item
            (sha, mode, name) = item
            is_dir = S_ISDIR(mode)
            for tio in range((ti + 1), (ti + nt)):
                tio = (tio % nt)
                entries[tio] = _find_by_name(trees_data[tio], name, is_dir, ii)
            if is_dir:
                out.extend(traverse_trees_recursive(odb, [((ei and ei[0]) or None) for ei in entries], ((path_prefix + name) + '/')))
            else:
                out_append(tuple((_to_full_path(e, path_prefix) for e in entries)))
            tree_data[ii] = None
        del tree_data[:]
    return out
