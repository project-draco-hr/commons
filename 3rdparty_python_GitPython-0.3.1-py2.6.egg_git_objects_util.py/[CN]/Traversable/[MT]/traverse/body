def traverse(self, predicate=(lambda i, d: True), prune=(lambda i, d: False), depth=(-1), branch_first=True, visit_once=True, ignore_self=1, as_edge=False):
    ':return: iterator yieling of items found when traversing self\n\t\t\t\n\t\t:param predicate: f(i,d) returns False if item i at depth d should not be included in the result\n\t\t\t\n\t\t:param prune: \n\t\t\tf(i,d) return True if the search should stop at item i at depth d.\n\t\t\tItem i will not be returned.\n\t\t\t\n\t\t:param depth:\n\t\t\tdefine at which level the iteration should not go deeper\n\t\t\tif -1, there is no limit\n\t\t\tif 0, you would effectively only get self, the root of the iteration\n\t\t\ti.e. if 1, you would only get the first level of predessessors/successors\n\t\t\t\n\t\t:param branch_first:\n\t\t\tif True, items will be returned branch first, otherwise depth first\n\t\t\t\n\t\t:param visit_once:\n\t\t\tif True, items will only be returned once, although they might be encountered\n\t\t\tseveral times. Loops are prevented that way.\n\t\t\n\t\t:param ignore_self:\n\t\t\tif True, self will be ignored and automatically pruned from\n\t\t\tthe result. Otherwise it will be the first item to be returned.\n\t\t\tIf as_edge is True, the source of the first edge is None\n\t\t\t\n\t\t:param as_edge:\n\t\t\tif True, return a pair of items, first being the source, second the \n\t\t\tdestinatination, i.e. tuple(src, dest) with the edge spanning from \n\t\t\tsource to destination'
    visited = set()
    stack = Deque()
    stack.append((0, self, None))

    def addToStack(stack, item, branch_first, depth):
        lst = self._get_intermediate_items(item)
        if (not lst):
            return
        if branch_first:
            stack.extendleft(((depth, i, item) for i in lst))
        else:
            reviter = ((depth, lst[i], item) for i in range((len(lst) - 1), (-1), (-1)))
            stack.extend(reviter)
    while stack:
        (d, item, src) = stack.pop()
        if (visit_once and (item in visited)):
            continue
        if visit_once:
            visited.add(item)
        rval = ((as_edge and (src, item)) or item)
        if prune(rval, d):
            continue
        skipStartItem = (ignore_self and (item is self))
        if ((not skipStartItem) and predicate(rval, d)):
            yield rval
        nd = (d + 1)
        if ((depth > (-1)) and (nd > depth)):
            continue
        addToStack(stack, item, branch_first, nd)
