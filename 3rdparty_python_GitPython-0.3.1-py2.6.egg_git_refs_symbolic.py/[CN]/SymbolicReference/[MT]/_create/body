@classmethod
def _create(cls, repo, path, resolve, reference, force, logmsg=None):
    'internal method used to create a new symbolic reference.\n\t\tIf resolve is False, the reference will be taken as is, creating \n\t\ta proper symbolic reference. Otherwise it will be resolved to the \n\t\tcorresponding object and a detached symbolic reference will be created\n\t\tinstead'
    full_ref_path = cls.to_full_path(path)
    abs_ref_path = join(repo.git_dir, full_ref_path)
    target = reference
    if resolve:
        target = repo.rev_parse(str(reference))
    if ((not force) and isfile(abs_ref_path)):
        target_data = str(target)
        if isinstance(target, SymbolicReference):
            target_data = target.path
        if (not resolve):
            target_data = ('ref: ' + target_data)
        existing_data = open(abs_ref_path, 'rb').read().strip()
        if (existing_data != target_data):
            raise OSError(('Reference at %r does already exist, pointing to %r, requested was %r' % (full_ref_path, existing_data, target_data)))
    ref = cls(repo, full_ref_path)
    ref.set_reference(target, logmsg)
    return ref
