def execute(self):
    "Until we've processed all targets, execute the following loop:\n        - spawn new compiles if we're below the limit of concurrently running compiles, and\n        - poll the currently running compiles to see if any are done."
    num_nodes = len(self._tree.nodes)
    while (len(self._processed_nodes) < num_nodes):
        time.sleep(0.1)
        if (not self._loop_once()):
            break
    result_msg = ('Nothing left to spawn' if ((len(self._processed_nodes) == num_nodes) and (not self._failed_compiles)) else 'Caught failure')
    self._logger.info(('\n%s after compiling %d targets out of %d:' % (result_msg, len(self._processed_nodes), len(self._tree.nodes))))
    for node in self._processed_nodes:
        self._logger.debug(('\t%s' % node.data.target.id))
    self._logger.debug('')
    self._logger.info(('%d still in flight:' % len(self._in_flight_target_nodes)))
    for node in self._in_flight_target_nodes:
        self._logger.info(('\t%s' % node.data.target.id))
    self._logger.info('')
    success = True
    for compile_process in self._compile_processes:
        compile_process.wait()
        if (compile_process.returncode != 0):
            target_node_set = self._compiling_nodes_by_process[compile_process]
            self._logger.warn(('Caught compile failure: %s' % ','.join([str(t) for t in target_node_set])))
            success = False
            self._failed_compiles.append(target_node_set)
    if (len(self._failed_compiles) > 0):
        raise TaskError(('Failed compiles:\n%s' % '\n\t'.join([str(t) for t in self._failed_compiles])))
    return success
