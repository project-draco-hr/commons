def __init__(self, name, source=None, dependencies=None, entry_point=None, inherit_path=False, zip_safe=True, always_write_cache=False, repositories=None, indices=None, ignore_errors=False, allow_pypi=False, platforms=(), compatibility=None, exclusives=None):
    "\n    :param name: target name\n    :param source: the python source file that becomes this binary's __main__.\n      If None specified, drops into an interpreter by default.\n    :param dependencies: List of :class:`twitter.pants.base.target.Target` instances\n      this target depends on.\n    :type dependencies: list of targets\n    :param entry_point: the default entry point for this binary.  if None, drops into the entry\n      point that is defined by source\n    :param inherit_path: inherit the sys.path of the environment that this binary runs in\n    :param zip_safe: whether or not this binary is safe to run in compacted (zip-file) form\n    :param always_write_cache: whether or not the .deps cache of this PEX file should always\n      be written to disk.\n    :param repositories: a list of repositories to query for dependencies.\n    :param indices: a list of indices to use for packages.\n    :param platforms: extra platforms to target when building this binary.\n    :param compatibility: either a string or list of strings that represents\n      interpreter compatibility for this target, using the Requirement-style format,\n      e.g. ``'CPython>=3', or just ['>=2.7','<3']`` for requirements agnostic to interpreter class.\n    :param dict exclusives: An optional dict of exclusives tags. See CheckExclusives for details.\n    "
    Target.__init__(self, name, exclusives=exclusives)
    if ((source is None) and (entry_point is None)):
        raise TargetDefinitionException(self, 'A python binary target must specify either source or entry_point.')
    PythonTarget.__init__(self, name, ([] if (source is None) else [source]), compatibility=compatibility, dependencies=dependencies, exclusives=exclusives)
    if ((not isinstance(platforms, (list, tuple))) and (not isinstance(platforms, Compatibility.string))):
        raise TargetDefinitionException(self, 'platforms must be a list, tuple or string.')
    self._entry_point = entry_point
    self._inherit_path = bool(inherit_path)
    self._zip_safe = bool(zip_safe)
    self._always_write_cache = bool(always_write_cache)
    self._repositories = maybe_list((repositories or []))
    self._indices = maybe_list((indices or []))
    self._ignore_errors = bool(ignore_errors)
    self._platforms = tuple(maybe_list((platforms or [])))
    if (source and entry_point):
        entry_point_module = entry_point.split(':', 1)[0]
        source_entry_point = self._translate_to_entry_point(self.sources[0])
        if (entry_point_module != source_entry_point):
            raise TargetDefinitionException(self, ('Specified both source and entry_point but they do not agree: %s vs %s' % (source_entry_point, entry_point_module)))
