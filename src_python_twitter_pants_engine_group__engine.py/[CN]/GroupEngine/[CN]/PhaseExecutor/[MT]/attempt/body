def attempt(self, timer, explain):
    'Executes the named phase against the current context tracking goal executions in executed.\n      '

    def execute_task(goal, task, targets):
        'Execute and time a single goal that has had all of its dependencies satisfied.'
        with timer.timed(goal):
            if explain:
                self._context.log.debug(('Skipping execution of %s in explain mode' % goal.name))
            else:
                task.execute(targets)
    goals = self._phase.goals()
    if (not goals):
        raise TaskError(('No goals installed for phase %s' % self._phase))
    run_queue = []
    goals_by_group = {}
    for goal in goals:
        if goal.group:
            group_name = goal.group.name
            if (group_name not in goals_by_group):
                group_goals = [goal]
                run_queue.append((group_name, group_goals))
                goals_by_group[group_name] = group_goals
            else:
                goals_by_group[group_name].append(goal)
        else:
            run_queue.append((None, [goal]))
    with self._context.new_workunit(name=self._phase.name, labels=[WorkUnit.PHASE]):
        execution_phases = defaultdict(OrderedSet)
        for (group_name, goals) in run_queue:
            if (not group_name):
                goal = goals[0]
                execution_phases[self._phase].add(goal.name)
                with self._context.new_workunit(name=goal.name, labels=[WorkUnit.GOAL]):
                    execute_task(goal, self._tasks_by_goal[goal], self._context.targets())
            else:
                with self._context.new_workunit(name=group_name, labels=[WorkUnit.GROUP]):
                    goals_by_group_member = OrderedDict(((GroupMember.from_goal(g), g) for g in goals))
                    goal_chunks = []
                    if explain:
                        exclusive_chunks = [self._context.targets()]
                    else:
                        exclusive_chunks = ExclusivesIterator.from_context(self._context)
                    for exclusive_chunk in exclusive_chunks:
                        group_chunks = GroupIterator(filter((lambda t: t.is_concrete), exclusive_chunk), goals_by_group_member.keys())
                        goal_chunks.extend(group_chunks)
                    self._context.log.debug(('::: created chunks(%d)' % len(goal_chunks)))
                    for (i, (group_member, goal_chunk)) in enumerate(goal_chunks):
                        self._context.log.debug(('  chunk(%d) [flavor=%s]:\n\t%s' % (i, group_member.name, '\n\t'.join(sorted(map(str, goal_chunk))))))
                    for (group_member, goal_chunk) in goal_chunks:
                        goal = goals_by_group_member[group_member]
                        execution_phases[self._phase].add((group_name, goal.name))
                        with self._context.new_workunit(name=goal.name, labels=[WorkUnit.GOAL]):
                            execute_task(goal, self._tasks_by_goal[goal], goal_chunk)
        if explain:
            tasks_by_goalname = dict(((goal.name, task.__class__.__name__) for (goal, task) in self._tasks_by_goal.items()))

            def expand_goal(goal):
                if (len(goal) == 2):
                    (group_name, goal_name) = goal
                    task_name = tasks_by_goalname[goal_name]
                    return ('%s:%s->%s' % (group_name, goal_name, task_name))
                else:
                    task_name = tasks_by_goalname[goal]
                    return ('%s->%s' % (goal, task_name))
            for (phase, goals) in execution_phases.items():
                goal_to_task = ', '.join((expand_goal(goal) for goal in goals))
                print ('%s [%s]' % (phase, goal_to_task))
