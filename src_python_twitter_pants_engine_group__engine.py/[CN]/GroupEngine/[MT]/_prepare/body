@classmethod
def _prepare(cls, context, phases):
    tasks_by_goal = {}
    prepared_goals = set()
    round_num = 0
    while True:
        phases = list(cls.execution_order(phases))
        if (prepared_goals == reduce((lambda goals, p: (goals | set(p.goals()))), phases, set())):
            break
        round_num += 1
        context.log.debug(('Preparing goals in round %d' % round_num))
        for phase in reversed(phases):
            for goal in reversed(phase.goals()):
                if (goal not in prepared_goals):
                    context.log.debug(('preparing: %s:%s' % (phase.name, goal.name)))
                    prepared_goals.add(goal)
                    task = goal.task_type(context)
                    tasks_by_goal[goal] = task
    return map((lambda p: cls.PhaseExecutor(context, p, tasks_by_goal)), phases)
