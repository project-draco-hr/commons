def reset(self, commit='HEAD', index=True, working_tree=False, paths=None, **kwargs):
    'Reset our HEAD to the given commit optionally synchronizing \n\t\tthe index and working tree. The reference we refer to will be set to \n\t\tcommit as well.\n\t\t\n\t\t:param commit:\n\t\t\tCommit object, Reference Object or string identifying a revision we \n\t\t\tshould reset HEAD to.\n\t\t\t\n\t\t:param index:\n\t\t\tIf True, the index will be set to match the given commit. Otherwise\n\t\t\tit will not be touched.\n\t\t\n\t\t:param working_tree:\n\t\t\tIf True, the working tree will be forcefully adjusted to match the given\n\t\t\tcommit, possibly overwriting uncommitted changes without warning.\n\t\t\tIf working_tree is True, index must be true as well\n\t\t\n\t\t:param paths:\n\t\t\tSingle path or list of paths relative to the git root directory\n\t\t\tthat are to be reset. This allows to partially reset individual files.\n\t\t\n\t\t:param kwargs:\n\t\t\tAdditional arguments passed to git-reset. \n\t\t\n\t\t:return: self'
    mode = '--soft'
    add_arg = None
    if index:
        mode = '--mixed'
        if paths:
            mode = None
    if working_tree:
        mode = '--hard'
        if (not index):
            raise ValueError('Cannot reset the working tree if the index is not reset as well')
    if paths:
        add_arg = '--'
    try:
        self.repo.git.reset(mode, commit, add_arg, paths, **kwargs)
    except GitCommandError as e:
        if (e.status != 1):
            raise
    return self
