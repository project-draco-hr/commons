@with_rw_repo('0.1.6')
def test_head_reset(self, rw_repo):
    cur_head = rw_repo.head
    old_head_commit = cur_head.commit
    new_head_commit = cur_head.ref.commit.parents[0]
    cur_head.reset(new_head_commit, index=True)
    assert (cur_head.reference.commit == new_head_commit)
    self.failUnlessRaises(ValueError, cur_head.reset, new_head_commit, index=False, working_tree=True)
    new_head_commit = new_head_commit.parents[0]
    cur_head.reset(new_head_commit, index=True, working_tree=True)
    assert (cur_head.reference.commit == new_head_commit)
    rw_repo.index.reset(old_head_commit.parents[0])
    cur_head.reset(cur_head, paths='test')
    cur_head.reset(new_head_commit, paths='lib')
    self.failUnlessRaises(GitCommandError, cur_head.reset, new_head_commit, working_tree=True, paths='lib')
    cur_head.reset(new_head_commit)
    rw_repo.index.checkout(['lib'], force=True)
    heads = rw_repo.heads
    assert heads
    for head in heads:
        cur_head.reference = head
        assert (cur_head.reference == head)
        assert isinstance(cur_head.reference, Head)
        assert (cur_head.commit == head.commit)
        assert (not cur_head.is_detached)
    active_head = heads[0]
    curhead_commit = active_head.commit
    cur_head.reference = curhead_commit
    assert (cur_head.commit == curhead_commit)
    assert cur_head.is_detached
    self.failUnlessRaises(TypeError, getattr, cur_head, 'reference')
    some_tag = rw_repo.tags[0]
    cur_head.reference = some_tag
    assert (not cur_head.is_detached)
    assert (cur_head.commit == some_tag.commit)
    assert isinstance(cur_head.reference, TagReference)
    cur_head.reference = active_head
    self.failUnlessRaises(ValueError, setattr, cur_head, 'reference', 'that')
    commit = 'HEAD'
    prev_head_commit = cur_head.commit
    for (count, new_name) in enumerate(('my_new_head', 'feature/feature1')):
        actual_commit = (commit + ('^' * count))
        new_head = Head.create(rw_repo, new_name, actual_commit)
        assert new_head.is_detached
        assert (cur_head.commit == prev_head_commit)
        assert isinstance(new_head, Head)
        Head.create(rw_repo, new_name, new_head.commit)
        self.failUnlessRaises(OSError, Head.create, rw_repo, new_name, new_head.commit.parents[0])
        new_head = Head.create(rw_repo, new_name, actual_commit, force=True)
        old_path = new_head.path
        old_name = new_head.name
        assert (new_head.rename('hello').name == 'hello')
        assert (new_head.rename('hello/world').name == 'hello/world')
        assert ((new_head.rename(old_name).name == old_name) and (new_head.path == old_path))
        tmp_head = Head.create(rw_repo, 'tmphead')
        self.failUnlessRaises(GitCommandError, tmp_head.rename, new_head)
        tmp_head.rename(new_head, force=True)
        assert ((tmp_head == new_head) and (tmp_head.object == new_head.object))
        logfile = RefLog.path(tmp_head)
        assert os.path.isfile(logfile)
        Head.delete(rw_repo, tmp_head)
        assert (not os.path.isfile(logfile))
        heads = rw_repo.heads
        assert ((tmp_head not in heads) and (new_head not in heads))
    self.failUnlessRaises(TypeError, RemoteReference.create, rw_repo, 'some_name')
    tag_name = '1.0.2'
    light_tag = TagReference.create(rw_repo, tag_name)
    self.failUnlessRaises(GitCommandError, TagReference.create, rw_repo, tag_name)
    light_tag = TagReference.create(rw_repo, tag_name, 'HEAD~1', force=True)
    assert isinstance(light_tag, TagReference)
    assert (light_tag.name == tag_name)
    assert (light_tag.commit == cur_head.commit.parents[0])
    assert (light_tag.tag is None)
    other_tag_name = 'releases/1.0.2RC'
    msg = 'my mighty tag\nsecond line'
    obj_tag = TagReference.create(rw_repo, other_tag_name, message=msg)
    assert isinstance(obj_tag, TagReference)
    assert (obj_tag.name == other_tag_name)
    assert (obj_tag.commit == cur_head.commit)
    assert (obj_tag.tag is not None)
    TagReference.delete(rw_repo, light_tag, obj_tag)
    tags = rw_repo.tags
    assert ((light_tag not in tags) and (obj_tag not in tags))
    remote_refs_so_far = 0
    remotes = rw_repo.remotes
    assert remotes
    for remote in remotes:
        refs = remote.refs
        RemoteReference.delete(rw_repo, *refs)
        remote_refs_so_far += len(refs)
        for ref in refs:
            assert (ref.remote_name == remote.name)
    assert remote_refs_so_far
    for remote in remotes:
        self.failUnlessRaises(AssertionError, getattr, remote, 'refs')
    if cur_head.is_detached:
        cur_head.reference = rw_repo.heads[0]
    head = cur_head.reference
    old_commit = head.commit
    head.commit = old_commit.parents[0]
    assert (head.commit == old_commit.parents[0])
    assert (head.commit == cur_head.commit)
    head.commit = old_commit
    head_tree = head.commit.tree
    self.failUnlessRaises(ValueError, setattr, head, 'commit', head_tree)
    assert (head.commit == old_commit)
    head.object = head_tree
    assert (head.object == head_tree)
    self.failUnlessRaises(TypeError, getattr, head, 'commit')
    assert (not cur_head.is_detached)
    head.object = old_commit
    cur_head.reference = head.commit
    assert cur_head.is_detached
    parent_commit = head.commit.parents[0]
    assert cur_head.is_detached
    cur_head.commit = parent_commit
    assert (cur_head.is_detached and (cur_head.commit == parent_commit))
    cur_head.reference = head
    assert (not cur_head.is_detached)
    cur_head.commit = parent_commit
    assert (not cur_head.is_detached)
    assert (head.commit == parent_commit)
    active_branch = rw_repo.active_branch
    for head in rw_repo.heads:
        checked_out_head = head.checkout()
        assert (checked_out_head == head)
    new_head = active_branch.checkout(b='new_head')
    assert (active_branch != rw_repo.active_branch)
    assert (new_head == rw_repo.active_branch)
    open(new_head.commit.tree.blobs[(-1)].abspath, 'w').close()
    assert len(new_head.commit.diff(None))
    far_away_head = rw_repo.create_head('far_head', 'HEAD~100')
    self.failUnlessRaises(GitCommandError, far_away_head.checkout)
    assert (active_branch == active_branch.checkout(force=True))
    assert (rw_repo.head.reference != far_away_head)
    partial_ref = 'sub/ref'
    full_ref = ('refs/%s' % partial_ref)
    ref = Reference.create(rw_repo, partial_ref)
    assert (ref.path == full_ref)
    assert (ref.object == rw_repo.head.commit)
    self.failUnlessRaises(OSError, Reference.create, rw_repo, full_ref, 'HEAD~20')
    assert (Reference.create(rw_repo, full_ref, 'HEAD').path == full_ref)
    Reference.delete(rw_repo, full_ref)
    ref = Reference.create(rw_repo, full_ref)
    assert (ref.path == full_ref)
    assert (ref.object == rw_repo.head.commit)
    ref = Reference.create(rw_repo, partial_ref, 'HEAD~1', force=True)
    assert (ref.path == full_ref)
    assert (ref.object == rw_repo.head.commit.parents[0])
    orig_obj = ref.object
    for name in ('refs/absname', 'rela_name', 'feature/rela_name'):
        ref_new_name = ref.rename(name)
        assert isinstance(ref_new_name, Reference)
        assert (name in ref_new_name.path)
        assert (ref_new_name.object == orig_obj)
        assert (ref_new_name == ref)
    self.failUnlessRaises(ValueError, getattr, Reference(rw_repo, 'refs/doesntexist'), 'commit')
    ex_ref_path = far_away_head.path
    self.failUnlessRaises(OSError, ref.rename, ex_ref_path)
    far_away_head.commit = ref.commit
    ref.rename(ex_ref_path)
    assert ((ref.path == ex_ref_path) and (ref.object == orig_obj))
    assert (ref.rename(ref.path).path == ex_ref_path)
    symref_path = 'symrefs/sym'
    symref = SymbolicReference.create(rw_repo, symref_path, cur_head.reference)
    assert (symref.path == symref_path)
    assert (symref.reference == cur_head.reference)
    self.failUnlessRaises(OSError, SymbolicReference.create, rw_repo, symref_path, cur_head.reference.commit)
    (SymbolicReference.create(rw_repo, symref.path, symref.reference).path == symref.path)
    SymbolicReference.delete(rw_repo, symref)
    symref = SymbolicReference.create(rw_repo, symref_path, cur_head.reference)
    symbol_ref_path = 'refs/symbol_ref'
    symref = SymbolicReference(rw_repo, symbol_ref_path)
    assert (symref.path == symbol_ref_path)
    symbol_ref_abspath = os.path.join(rw_repo.git_dir, symref.path)
    symref.reference = new_head
    assert (symref.reference == new_head)
    assert os.path.isfile(symbol_ref_abspath)
    assert (symref.commit == new_head.commit)
    for name in ('absname', 'folder/rela_name'):
        symref_new_name = symref.rename(name)
        assert isinstance(symref_new_name, SymbolicReference)
        assert (name in symref_new_name.path)
        assert (symref_new_name.reference == new_head)
        assert (symref_new_name == symref)
        assert (not symref.is_detached)
    Reference.create(rw_repo, full_ref)
    rw_repo.git.pack_refs(all=True, prune=True)
    heads = rw_repo.heads
    assert heads
    assert (new_head in heads)
    assert (active_branch in heads)
    assert rw_repo.tags
    for symref in SymbolicReference.iter_items(rw_repo):
        assert (not symref.is_detached)
    rw_repo.head.reference = rw_repo.head.commit
    deleted_refs = set()
    for ref in Reference.iter_items(rw_repo):
        if ref.is_detached:
            ref.delete(rw_repo, ref)
            deleted_refs.add(ref)
    assert deleted_refs
    for ref in Reference.iter_items(rw_repo):
        if ref.is_detached:
            assert (ref not in deleted_refs)
    rw_repo.head.reference = Head.create(rw_repo, 'master')
    assert os.path.isfile(os.path.join(rw_repo.git_dir, 'HEAD'))
    refs = list(SymbolicReference.iter_items(rw_repo))
    assert (len(refs) == 1)
    for path in ('basename', 'dir/somename', 'dir2/subdir/basename'):
        fpath = Reference.to_full_path(path)
        ref_fp = Reference.from_path(rw_repo, fpath)
        assert (not ref_fp.is_valid())
        ref = Reference(rw_repo, fpath)
        assert (ref == ref_fp)
        ref.commit = rw_repo.head.commit
        assert ref.is_valid()
        Reference.delete(ref.repo, ref.path)
        assert (not ref.is_valid())
        self.failUnlessRaises(ValueError, setattr, ref, 'commit', 'nonsense')
        assert (not ref.is_valid())
        Reference.delete(ref.repo, ref.path)
        assert (not ref.is_valid())
        ref.object = rw_repo.head.commit
        assert ref.is_valid()
        Reference.delete(ref.repo, ref.path)
        assert (not ref.is_valid())
        self.failUnlessRaises(ValueError, setattr, ref, 'object', 'nonsense')
        assert (not ref.is_valid())
