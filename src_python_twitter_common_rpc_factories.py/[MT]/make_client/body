def make_client(client_iface, *args, **kw):
    '\n    Ex, basic usage:\n      make_client(UserService, \'localhost\', 9999)\n\n    Ex, make an SSL socket server (see also make_server)\n      make_client(UserService, \'smf1-amk-25-sr1.prod.twitter.com\', 9999,\n                  connection=TSocket.TSSLServerSocket,\n                  ca_certs=...)\n\n    Ex, make a finagle client:\n      make_client(UserService, \'localhost\', 9999,\n                  protocol=TFinagleProtocol)\n\n    And one with a client_id\n      make_client(UserService, \'localhost\', 9999,\n                  protocol=functools.partial(TFinagleProtocol, client_id="test_client"))\n\n    (this is equivalent to\n      make_client(UserService, \'localhost\', 9999,\n                  protocol=TFinagleProtocolWithClientId("test_client")))\n\n    Ex, bind to a unix_socket instead of host/port pair (unix_socket is kwarg to\n    TSocket.TSocket):\n      make_client(UserService, unix_socket=...opened-fifo...)\n\n    N.B. This can also be used as a contextmanager or with contextlib.closing to\n         automatically handle closing of the thrift connection (or manually via close()).\n\n      with make_client(...) as c:\n        c.somefunc()\n  '
    protocol_class = kw.pop('protocol', TBinaryProtocol.TBinaryProtocolAccelerated)
    transport_class = kw.pop('transport', TTransport.TFramedTransport)
    connection_class = kw.pop('connection', TSocket.TSocket)
    connection = ConnectionFactory(connection_class)(*args, **kw)
    connection.open()
    return ClientFactory(client_iface, connection)(ProtocolFactory(protocol_class)(TransportFactory(transport_class)(connection)))
