@staticmethod
def attempt(context, phases):
    '\n      Attempts to reach the goals for the supplied phases, optionally recording phase timings and\n      then logging then when all specified phases have completed.\n    '
    executed = OrderedDict()

    def emit_timings():
        if context.timer:
            for (phase, timings) in executed.items():
                for (goal, times) in timings.items():
                    context.timer.log(('%s:%s' % (phase, goal)), times)
    try:
        tasks_by_goal = {}
        expanded = OrderedSet()
        prepared = set()
        round = 0
        while True:
            goals = list(Phase.execution_order(phases))
            if (set(goals) == prepared):
                break
            else:
                round += 1
                context.log.debug(('Preparing goals in round %d' % round))
                for goal in reversed(goals):
                    if (goal not in prepared):
                        phase = Phase.of(goal)
                        expanded.add(phase)
                        context.log.debug(('preparing: %s:%s' % (phase, goal.name)))
                        prepared.add(goal)
                        task = goal.prepare(context)
                        tasks_by_goal[goal] = task
        context.log.debug(('Executing goals in phases %s' % ' -> '.join(map(str, reversed(expanded)))))
        for phase in phases:
            Group.execute(phase, tasks_by_goal, context, executed)
        emit_timings()
        return 0
    except (TaskError, GoalError) as e:
        message = ('%s' % e)
        if message:
            print(('\nFAILURE: %s\n' % e))
        else:
            print('\nFAILURE\n')
        emit_timings()
        return 1
