@classmethod
def iter_logical_lines(cls, blob):
    'Returns an iterator of (start_line, stop_line, indent) for logical lines given the source\n       blob.\n    '
    contents = []
    line_number_start = None

    def translate_logical_line(start, end, contents):
        while (contents[0] == '\n'):
            start += 1
            contents.pop(0)
        while (contents[(-1)] == '\n'):
            end -= 1
            contents.pop()
        return (start, (end + 1), (len(contents[0]) if contents[0].isspace() else 0))
    for token in cls.iter_tokens(blob):
        (token_type, token_text, token_start) = token[0:3]
        if (token_type in cls.SKIP_TOKENS):
            continue
        contents.append(token_text)
        if (line_number_start is None):
            line_number_start = token_start[0]
        elif (token_type in (tokenize.NEWLINE, tokenize.ENDMARKER)):
            yield translate_logical_line(line_number_start, (token_start[0] + (1 if (token_type is tokenize.NEWLINE) else (-1))), list(filter(None, contents)))
            contents = []
            line_number_start = None
