def _compute_exclusives_conflicts(self, targets):
    'Compute the set of distinct chunks of targets that are required based on exclusives.\n    If two targets have different values for a particular exclusives tag,\n    then those targets must end up in different chunks.\n    This method computes the exclusives values that define each chunk.\n    e.g.: if target a has exclusives {"x": "1", "z": "1"}, target b has {"x": "2"},\n    target c has {"y", "1"}, and target d has {"y", "2", "z": "1"}, then we need to\n    divide into chunks on exclusives tags "x" and "y". We don\'t need to include\n    "z" in the chunk specification, because there are no conflicts on z.\n\n    Parameters:\n      targets: a list of the targets being built.\n    Return: the set of exclusives tags that should be used for chunking.\n    '
    exclusives_map = defaultdict(set)
    for t in targets:
        if (t.exclusives is not None):
            for k in t.exclusives:
                exclusives_map[k] |= t.exclusives[k]
    conflicting_keys = defaultdict(set)
    for k in exclusives_map:
        if (len(exclusives_map[k]) > 1):
            conflicting_keys[k] = exclusives_map[k]
    return conflicting_keys
