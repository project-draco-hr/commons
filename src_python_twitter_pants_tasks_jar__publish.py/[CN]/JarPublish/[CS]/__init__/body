def __init__(self, context, scm=None):
    Task.__init__(self, context)
    ScmPublish.__init__(self, (scm or get_scm()), self.context.config.getlist(JarPublish._CONFIG_SECTION, 'restrict_push_branches'))
    self.outdir = os.path.join(context.config.getdefault('pants_workdir'), 'publish')
    self.cachedir = os.path.join(self.outdir, 'cache')
    self._jvmargs = context.config.getlist(JarPublish._CONFIG_SECTION, 'ivy_jvmargs', default=[])
    if context.options.jar_publish_local:
        local_repo = dict(resolver='publish_local', path=os.path.abspath(os.path.expanduser(context.options.jar_publish_local)), confs=['*'], auth=None)
        self.repos = defaultdict((lambda : local_repo))
        self.commit = False
        self.snapshot = context.options.jar_publish_local_snapshot
    else:
        self.repos = context.config.getdict(JarPublish._CONFIG_SECTION, 'repos')
        if (not self.repos):
            raise TaskError('This repo is not yet set for publishing to the world! Please re-run with --publish-local')
        for (repo, data) in self.repos.items():
            auth = data.get('auth')
            if auth:
                credentials = context.resolve(auth).next()
                user = credentials.username(data['resolver'])
                password = credentials.password(data['resolver'])
                self.context.log.debug(('Found auth for repo=%s user=%s' % (repo, user)))
                self.repos[repo]['username'] = user
                self.repos[repo]['password'] = password
        self.commit = context.options.jar_publish_commit
        self.snapshot = False
    self.ivycp = context.config.getlist('ivy', 'classpath')
    self.ivysettings = context.config.get('jar-publish', 'ivy_settings')
    self.dryrun = context.options.jar_publish_dryrun
    self.transitive = context.options.jar_publish_transitive
    self.force = context.options.jar_publish_force

    def parse_jarcoordinate(coordinate):
        components = coordinate.split('#', 1)
        if (len(components) == 2):
            (org, name) = components
            return (org, name)
        else:
            try:
                address = Address.parse(get_buildroot(), coordinate)
                try:
                    target = Target.get(address)
                    if (not target):
                        siblings = Target.get_all_addresses(address.buildfile)
                        prompt = ('did you mean' if (len(siblings) == 1) else 'maybe you meant one of these')
                        raise TaskError(('%s => %s?:\n    %s' % (address, prompt, '\n    '.join((str(a) for a in siblings)))))
                    if (not target.is_exported):
                        raise TaskError(('%s is not an exported target' % coordinate))
                    return (target.provides.org, target.provides.name)
                except (ImportError, SyntaxError, TypeError):
                    raise TaskError(('Failed to parse %s' % address.buildfile.relpath))
            except IOError:
                raise TaskError(('No BUILD file could be found at %s' % coordinate))
    self.overrides = {}
    if context.options.jar_publish_override:

        def parse_override(override):
            try:
                (coordinate, rev) = override.split('=', 1)
                try:
                    rev = Semver.parse(rev)
                except ValueError as e:
                    raise TaskError(('Invalid version %s: %s' % (rev, e)))
                return (parse_jarcoordinate(coordinate), rev)
            except ValueError:
                raise TaskError(('Invalid override: %s' % override))
        self.overrides.update((parse_override(o) for o in context.options.jar_publish_override))
    self.restart_at = None
    if context.options.jar_publish_restart_at:
        self.restart_at = parse_jarcoordinate(context.options.jar_publish_restart_at)
    context.products.require('jars')
    context.products.require('source_jars')
