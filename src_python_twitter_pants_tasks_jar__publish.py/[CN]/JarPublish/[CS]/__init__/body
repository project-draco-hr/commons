def __init__(self, context, scm=None, restrict_push_branches=None):
    Task.__init__(self, context)
    self.scm = (scm or get_scm())
    if (self.scm is None):
        raise TaskError('Cannot publish JAR files without a configured source-control system.')
    self.restrict_push_branches = frozenset((restrict_push_branches or ()))
    self.outdir = context.config.get('jar-publish', 'workdir')
    self.cachedir = os.path.join(self.outdir, 'cache')
    if context.options.jar_publish_local:
        local_repo = dict(resolver='publish_local', path=os.path.abspath(os.path.expanduser(context.options.jar_publish_local)), confs=context.config.getlist('jar-publish', 'publish_local_confs', default=['*']), auth=None)
        self.repos = defaultdict((lambda : local_repo))
        self.commit = False
        self.snapshot = context.options.jar_publish_local_snapshot
    else:
        self.repos = context.config.getdict('jar-publish', 'repos')
        for (repo, data) in self.repos.items():
            auth = data.get('auth')
            if auth:
                credentials = context.resolve(auth).next()
                user = credentials.username()
                password = credentials.password()
                self.context.log.debug(('Found auth for repo: %s %s:%s' % (repo, user, password)))
                data['auth'] = (user, password)
        self.commit = context.options.jar_publish_commit
        self.snapshot = False
    self.ivycp = context.config.getlist('ivy', 'classpath')
    self.ivysettings = context.config.get('ivy', 'ivy_settings')
    self.dryrun = context.options.jar_publish_dryrun
    self.transitive = context.options.jar_publish_transitive
    self.force = context.options.jar_publish_force

    def parse_jarcoordinate(coordinate):
        components = coordinate.split('#', 1)
        if (len(components) == 2):
            (org, name) = components
            return (org, name)
        else:
            try:
                address = Address.parse(get_buildroot(), coordinate)
                try:
                    target = Target.get(address)
                    if (not target):
                        siblings = Target.get_all_addresses(address.buildfile)
                        prompt = ('did you mean' if (len(siblings) == 1) else 'maybe you meant one of these')
                        raise TaskError(('%s => %s?:\n    %s' % (address, prompt, '\n    '.join((str(a) for a in siblings)))))
                    if (not is_exported(target)):
                        raise TaskError(('%s is not an exported target' % coordinate))
                    return (target.provides.org, target.provides.name)
                except (ImportError, SyntaxError, TypeError):
                    raise TaskError(('Failed to parse %s' % address.buildfile.relpath))
            except IOError:
                raise TaskError(('No BUILD file could be found at %s' % coordinate))
    self.overrides = {}
    if context.options.jar_publish_overrides:

        def parse_override(override):
            try:
                (coordinate, rev) = override.split('=', 1)
                try:
                    rev = Semver.parse(rev)
                except ValueError as e:
                    raise TaskError(('Invalid version %s: %s' % (rev, e)))
                return (parse_jarcoordinate(coordinate), rev)
            except ValueError:
                raise TaskError(('Invalid override: %s' % override))
        self.overrides.update((parse_override(o) for o in context.options.jar_publish_overrides))
    self.restart_at = None
    if context.options.jar_publish_restart_at:
        self.restart_at = parse_jarcoordinate(context.options.jar_publish_restart_at)
    context.products.require('jars')
    context.products.require('source_jars')
    context.products.require('idl_jars')
    context.products.require('javadoc_jars')
