def check_targets(self, targets):
    invalid = defaultdict((lambda : defaultdict(set)))
    derived_by_target = dict()

    def collect(publish_target, walked_target):
        derived_by_target[walked_target.derived_from] = walked_target
        if ((not walked_target.has_sources()) or (not walked_target.sources)):
            invalid[publish_target][walked_target].add('No sources.')
        if (not walked_target.is_exported):
            invalid[publish_target][walked_target].add('Does not provide an artifact.')
    for target in targets:
        target.walk(functools.partial(collect, target), predicate=(lambda t: t.is_concrete))
    for (publish_target, invalid_targets) in list(invalid.items()):
        for (invalid_target, reasons) in list(invalid_targets.items()):
            derived_target = derived_by_target[invalid_target]
            if (derived_target not in invalid_targets):
                invalid_targets.pop(invalid_target)
        if (not invalid_targets):
            invalid.pop(publish_target)
    if invalid:
        msg = list()

        def first_address(pair):
            (first, _) = pair
            return str(first.address)
        for (publish_target, invalid_targets) in sorted(invalid.items(), key=first_address):
            msg.append(('\n  Cannot publish %s due to:' % publish_target.address))
            for (invalid_target, reasons) in sorted(invalid_targets.items(), key=first_address):
                for reason in sorted(reasons):
                    msg.append(('\n    %s - %s' % (invalid_target.address, reason)))
        raise TaskError(('The following errors must be resolved to publish.%s' % ''.join(msg)))
