def _generate_project_files(self, project, ivyfile, ivysettingsfile):

    def create_sourcepath(base, sources):

        def normalize_path_pattern(path):
            return (('%s/' % path) if (not path.endswith('/')) else path)
        includes = [normalize_path_pattern(source_set.path) for source_set in sources]
        excludes = []
        for source_set in sources:
            excludes.extend((normalize_path_pattern(exclude) for exclude in source_set.excludes))
        return TemplateData(base=base, includes=includes, excludes=excludes)
    configured_project = TemplateData(name=self.project_name, has_python=project.has_python)
    ivyconfig = dict(ivyXmlPath=os.path.relpath(ivyfile, project.root_dir), confs='*', ivySettingsPath=('file://%s' % ivysettingsfile), loadSettingsOnDemand='false', propertyFiles='', acceptedTypes='jar,bundle,ejb,maven-plugin', sourceTypes='source', javadocTypes='', sourceSuffixes='', javadocSuffixes='', alphaOrder='true', resolveInWorkspace='false', resolveBeforeLaunch='false')
    output_dir = os.path.join('target', 'eclipse')
    outdir = os.path.abspath(os.path.join(output_dir, 'bin'))
    if (not os.path.exists(outdir)):
        os.makedirs(outdir)
    source_sets = collections.defaultdict(OrderedSet)
    for source_set in project.sources:
        source_sets[source_set.source_base].add(source_set)
    configured_classpath = TemplateData(sourcepaths=[create_sourcepath(base, sources) for (base, sources) in source_sets.items()], has_tests=project.has_tests, has_ivy=True, ivyconfig=urllib.urlencode(ivyconfig).replace('&', '&amp;'), outdir=os.path.relpath(outdir, self.root_dir))
    with open(self.project_filename, 'w') as output:
        Generator(pkgutil.get_data(__name__, self.project_template), project=configured_project).write(output)
    with open(self.classpath_filename, 'w') as output:
        Generator(pkgutil.get_data(__name__, self.classpath_template), classpath=configured_classpath).write(output)
    if os.path.exists(self.apt_filename):
        os.remove(self.apt_filename)

    def has_apt():
        apt_targets = []

        def test_apt(t):
            if is_apt(t):
                apt_targets.append(t)
        for target in project.targets:
            target.walk(test_apt)
            if apt_targets:
                return True
        return False
    if has_apt():
        libs_base_path = os.path.join(output_dir, 'libs')
        libdir = os.path.abspath(libs_base_path)
        if (not os.path.exists(libdir)):
            os.makedirs(libdir)
        print('Retrieving apt libs...')
        retrieve_result = subprocess.call(['java', '-jar', self.ivy_jar, '-warn', '-settings', ivysettingsfile, '-ivy', ivyfile, '-retrieve', ('%s/%s/[conf]/[artifact].[ext]' % (self.root_dir, libs_base_path)), '-types', 'jar', '-sync', '-symlink'])
        if (retrieve_result != 0):
            print('Failed to retrieve apt libs.')
            return retrieve_result
        jarpaths = []
        for (path, _, filenames) in os.walk(libdir):
            for filename in filenames:
                jarpaths.append(os.path.join(path, filename))
        configured_factorypath = TemplateData(jarpaths=jarpaths)
        with open(self.apt_filename, 'w') as output:
            Generator(pkgutil.get_data(__name__, self.apt_template), factorypath=configured_factorypath).write(output)
        print('Generated apt config')
    if os.path.exists(self.pydev_filename):
        os.remove(self.pydev_filename)
    if project.has_python:
        with open(self.pydev_filename, 'w') as output:
            Generator(pkgutil.get_data(__name__, self.pydev_template), project=configured_project).write(output)
    return 0
