def execute(self, targets):
    java_targets = filter(JavaCompile._has_java_sources, reversed(InternalTarget.sort_targets(targets)))
    if java_targets:
        safe_mkdir(self._classes_dir)
        safe_mkdir(self._depfile_dir)
        with self.context.state('classpath', []) as cp:
            for conf in self._confs:
                cp.insert(0, (conf, self._resources_dir))
                cp.insert(0, (conf, self._classes_dir))
        with self.invalidated(java_targets, invalidate_dependants=True) as invalidated:
            if self._flatten:
                self.execute_single_compilation(invalidated.combined_invalid_versioned_targets(), cp)
            else:
                for vt in invalidated.all_versioned_targets():
                    self.execute_single_compilation(vt, cp)
        if self.context.products.isrequired('classes'):
            genmap = self.context.products.get('classes')
            for (target, classes_by_source) in self._deps.findclasses(java_targets).items():
                for (source, classes) in classes_by_source.items():
                    genmap.add(source, self._classes_dir, classes)
                    genmap.add(target, self._classes_dir, classes)
            for target in java_targets:
                if (is_apt(target) and target.processors):
                    basedir = os.path.join(self._resources_dir, target.id)
                    processor_info_file = os.path.join(basedir, _PROCESSOR_INFO_FILE)
                    self.write_processor_info(processor_info_file, target.processors)
                    genmap.add(target, basedir, [_PROCESSOR_INFO_FILE])
