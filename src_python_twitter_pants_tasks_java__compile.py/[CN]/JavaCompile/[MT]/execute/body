def execute(self, targets):
    java_targets = filter((lambda t: has_sources(t, '.java')), targets)
    if (not java_targets):
        return
    egroups = self.context.products.get_data('exclusives_groups')
    group_id = egroups.get_group_key_for_target(java_targets[0])
    for conf in self._confs:
        egroups.update_compatible_classpaths(group_id, [(conf, self._classes_dir)])
        egroups.update_compatible_classpaths(group_id, [(conf, self._resources_dir)])
    cp = egroups.get_classpath_for_group(group_id)
    with self.invalidated(java_targets, invalidate_dependents=True, partition_size_hint=self._partition_size_hint) as invalidation_check:
        if (not self.dry_run):
            for vts in invalidation_check.invalid_vts_partitioned:
                sources_by_target = self._process_target_partition(vts, cp)
                vts.update()
                if (self.get_artifact_cache() and self.context.options.write_to_artifact_cache):
                    self._write_to_artifact_cache(vts, sources_by_target)
            if self.context.products.isrequired('classes'):
                if os.path.exists(self._depfile):
                    sources_by_target = self._compute_sources_by_target(java_targets)
                    deps = Dependencies(self._classes_dir)
                    deps.load(self._depfile)
                    self._add_all_products_to_genmap(sources_by_target, deps.classes_by_source)
            all_processors = set()
            for target in java_targets:
                if (is_apt(target) and target.processors):
                    all_processors.update(target.processors)
            processor_info_file = os.path.join(self._classes_dir, _PROCESSOR_INFO_FILE)
            if os.path.exists(processor_info_file):
                with safe_open(processor_info_file, 'r') as f:
                    for processor in f:
                        all_processors.add(processor.strip())
            self.write_processor_info(processor_info_file, all_processors)
