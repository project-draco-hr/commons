@classmethod
def compiled_idl(cls, idl_dep, generated_deps=None, compiler=None, language=None, namespace_map=None):
    'Marks a jar as containing IDL files that should be fetched and processed locally.\n\n    idl_dep:        A dependency resolvable to a single jar library.\n    generated_deps: Dependencies for the code that will be generated from "idl_dep"\n    compiler:       The thrift compiler to apply to the fetched thrift IDL files.\n    language:       The language to generate code for - supported by some compilers\n    namespace_map:  A mapping from IDL declared namespaces to custom namespaces - supported by some\n                    compilers.\n    '
    deps = list(filter(is_concrete, idl_dep.resolve()))
    if (not (len(deps) == 1)):
        raise TaskError(('Can only arrange for compiled idl for a single dependency at a time, given:\n\t%s' % '\n\t'.join(map(str, deps))))
    jar = deps.pop()
    if (not isinstance(jar, JarDependency)):
        raise TaskError(('Can only arrange for compiled idl from a jar dependency, given: %s' % jar))
    request = (jar, compiler, language)
    namespace_signature = None
    if namespace_map:
        sha = hashlib.sha1()
        for (ns_from, ns_to) in sorted(namespace_map.items()):
            sha.update(ns_from)
            sha.update(ns_to)
        namespace_signature = sha.hexdigest()
    request += (namespace_signature,)
    if (request not in cls._PLACEHOLDER_BY_REQUEST):
        if (not cls._EXTRACT_BASE):
            config = Config.load()
            cls._EXTRACT_BASE = config.get('idl-extract', 'workdir')
            safe_mkdir(cls._EXTRACT_BASE)
            SourceRoot.register(cls._EXTRACT_BASE, JavaThriftLibrary)
        with ParseContext.temp(cls._EXTRACT_BASE):
            jar._configurations.append('idl')
            jar.with_artifact(configuration='idl', classifier='idl')
            target_name = '-'.join(filter(None, (jar.id, compiler, language, namespace_signature)))
            placeholder = JavaThriftLibrary(target_name, sources=None, dependencies=([jar] + (generated_deps or [])), compiler=compiler, language=language, namespace_map=namespace_map)
            cls._PLACEHOLDER_BY_REQUEST[request] = placeholder
            cls._PLACEHOLDERS_BY_JAR[jar].append(placeholder)
    return cls._PLACEHOLDER_BY_REQUEST[request]
