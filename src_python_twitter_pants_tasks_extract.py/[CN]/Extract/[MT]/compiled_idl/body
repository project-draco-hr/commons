@classmethod
@manual.builddict(tags=['anylang', 'thrift'])
def compiled_idl(cls, idl_deps, name=None, compiler=None, language=None, rpc_style=None, generated_deps=None, namespace_map=None):
    'Configure thrift IDL code generation.\n\n    This is where "things that represent thrift IDL files" converge with\n    a thrift compiler (and the compiler options) to generate code. For thrift\n    jar IDL dependencies fetching and extraction are scheduled as well.\n\n    Two usages are supported:\n\n    * Creating an addressable target that may be depended on by other targets\n      (this requires specifying the ``name`` parameter). This is the recommended\n      usage so many targets may depend on the same codegen. A typical usage\n      of ``namespace_map`` is for JVM languages to overload package names with\n      the target language to avoid classpath naming conflicts in mixed\n      language classpaths.\n    * Creating an inline anonymous target. This is typically used in\n      conjunction with ``namespace_map`` when generating code into a custom\n      namespace.\n\n    Let\'s examine an example addressable target, which is the recommended\n    usage. Typically the thrift IDL owner would provide such a target for\n    others to depend on.\n\n    ::\n\n      compiled_idl(name=\'mybird-scala\'\n        idl_deps=[pants(\':idl\')],\n        compiler=\'scrooge\',\n        language=\'scala\',\n        namespace_map={\n          \'com.twitter.mybird.thriftjava\': \'com.twitter.mybird.thriftscala\',\n        }\n      )\n\n      thrift_library(name=\'idl\',\n        sources=globs(\'*.thrift\')\n      )\n\n    Now let\'s examine an example anonymous target usage. Notice how this\n    project chooses to generate code into a private namespace. It also chooses\n    to map thriftjava to thriftscala to avoid classpath issues.\n\n    ::\n\n      scala_library(name=\'mybird\',\n        dependencies=[\n          compiled_idl(\n            idl_deps=[pants(\'src/thrift/com/twitter/otherbird\')],\n            compiler=\'scrooge\',\n            language=\'scala\',\n            namespace_map={\n              \'com.twitter.otherbird.thriftjava\': \'com.twitter.mybird.otherbird.thriftscala\',\n            },\n          ),\n        ],\n        sources=globs(\'*.scala\'),\n      )\n\n    :param idl_deps: One or more dependencies resolvable to a set of\n      :class:`twitter.pants.targets.thrift_library.ThriftJar` or\n      :class:`twitter.pants.targets.thrift_library.ThriftLibrary` targets.\n    :param string name: Name of the returned target so it can be\n      referenced. Anonymous (un-addressable) by default.\n    :param string compiler: Name of the thrift compiler to generate sources with.\n    :param string language: Language to generate code for\n      (only supported by some compilers).\n    :param string rpc_style: Style of RPC service stubs to generate\n      (only supported by some compilers).\n    :param generated_deps: Dependencies for the code that will be generated\n      from the ``idl_deps``.\n    :param namespace_map: A mapping from IDL declared namespaces to custom\n      namespaces (only supported by some compilers).\n    :returns: A :class:`twitter.pants.targets.jar_library.JarLibrary` that\n      depends on\n      :class:`twitter.pants.targets.java_thrift_library.JavaThriftLibrary`\n      targets that own the generated code.\n    '

    def stitch_dependencies(synthetic_jarlib):
        thrift_jars = OrderedSet()
        thrift_libraries = OrderedSet()
        invalid = OrderedSet()

        def is_thrift_jar(dep):
            return isinstance(dep, ThriftJar)

        def accumulate(dep):
            if is_thrift_jar(dep):
                thrift_jars.add(dep)
            elif isinstance(dep, ThriftLibrary):
                thrift_libraries.add(dep)
                thrift_jars.update(filter(is_thrift_jar, dep.dependencies))
            else:
                invalid.add(dep)
        for idl_dep in maybe_list(idl_deps, expected_type=(JarLibrary, Pants, ThriftJar, ThriftLibrary), raise_type=TaskError):
            idl_dep.walk(accumulate, predicate=(lambda t: t.is_concrete))
        if invalid:
            raise TaskError(('Can only arrange for compiled idl from thrift jars and thrift libraries, found the following non-compliant dependencies:\n\t%s' % '\n\t'.join(map(str, invalid))))
        synthetic_by_idl = {}
        for thrift_jar in thrift_jars:
            synthetic_by_idl[thrift_jar] = cls._register_jar(thrift_jar, compiler, language, rpc_style, generated_deps, namespace_map)
        for thrift_library in thrift_libraries:
            synthetic_by_idl[thrift_library] = cls._register_library(thrift_library, compiler, language, rpc_style, generated_deps, namespace_map)
        for thrift_library in thrift_libraries:
            synthetic_deps = OrderedSet()
            for dependency in thrift_library.dependencies:
                for dep in dependency.resolve():
                    if dep.is_concrete:
                        synthetic_deps.add(synthetic_by_idl[dep])
            synthetic_by_idl[thrift_library].update_dependencies(synthetic_deps)
        synthetic_jarlib.dependencies.update(synthetic_by_idl.values())
    synthetic_lib = (JarLibrary(name=name, dependencies=()) if name else AnonymousDeps())
    ParseContext.locate().on_context_exit(stitch_dependencies, synthetic_lib)
    return synthetic_lib
