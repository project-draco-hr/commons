def __init__(self, run_tracker, root_dir, parser, argv):
    Command.__init__(self, run_tracker, root_dir, parser, argv)
    if (not self.args):
        self.error('A spec argument is required')
    self.config = Config.load()
    self.interpreter_cache = PythonInterpreterCache(self.config, logger=self.debug)
    self.interpreter_cache.setup()
    interpreters = self.interpreter_cache.select_interpreter(list(self.interpreter_cache.matches(([self.options.interpreter] if self.options.interpreter else ['']))))
    if (len(interpreters) != 1):
        self.error('Unable to detect suitable interpreter.')
    else:
        self.debug(('Selected %s' % interpreters[0]))
    self.interpreter = interpreters[0]
    try:
        specs_end = self.args.index('--')
        if (len(self.args) > specs_end):
            self.build_args = self.args[(specs_end + 1):(len(self.args) + 1)]
        else:
            self.build_args = []
    except ValueError:
        specs_end = 1
        self.build_args = (self.args[1:] if (len(self.args) > 1) else [])
    self.targets = OrderedSet()
    for spec in self.args[0:specs_end]:
        try:
            address = Address.parse(root_dir, spec)
        except:
            self.error(('Problem parsing spec %s: %s' % (spec, traceback.format_exc())))
        try:
            target = Target.get(address)
        except:
            self.error(('Problem parsing BUILD target %s: %s' % (address, traceback.format_exc())))
        try:
            InternalTarget.check_cycles(target)
        except InternalTarget.CycleException as e:
            self.error(('Target contains an internal dependency cycle: %s' % e))
        if (not target):
            self.error(('Target %s does not exist' % address))
        self.targets.update((tgt for tgt in target.resolve() if tgt.is_concrete))
