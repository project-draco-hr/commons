def aggressive_tree_merge(odb, tree_shas):
    "\n\t:return: list of BaseIndexEntries representing the aggressive merge of the given\n\t\ttrees. All valid entries are on stage 0, whereas the conflicting ones are left \n\t\ton stage 1, 2 or 3, whereas stage 1 corresponds to the common ancestor tree, \n\t\t2 to our tree and 3 to 'their' tree.\n\t:param tree_shas: 1, 2 or 3 trees as identified by their binary 20 byte shas\n\t\tIf 1 or two, the entries will effectively correspond to the last given tree\n\t\tIf 3 are given, a 3 way merge is performed"
    out = list()
    out_append = out.append
    if (len(tree_shas) in (1, 2)):
        for entry in traverse_tree_recursive(odb, tree_shas[(-1)], ''):
            out_append(_tree_entry_to_baseindexentry(entry, 0))
        return out
    if (len(tree_shas) > 3):
        raise ValueError(('Cannot handle %i trees at once' % len(tree_shas)))
    for (base, ours, theirs) in traverse_trees_recursive(odb, tree_shas, ''):
        if (base is not None):
            if (ours is not None):
                if (theirs is not None):
                    if (((base[0] != ours[0]) and (base[0] != theirs[0]) and (ours[0] != theirs[0])) or ((base[1] != ours[1]) and (base[1] != theirs[1]) and (ours[1] != theirs[1]))):
                        out_append(_tree_entry_to_baseindexentry(base, 1))
                        out_append(_tree_entry_to_baseindexentry(ours, 2))
                        out_append(_tree_entry_to_baseindexentry(theirs, 3))
                    elif ((base[0] != ours[0]) or (base[1] != ours[1])):
                        out_append(_tree_entry_to_baseindexentry(ours, 0))
                    else:
                        out_append(_tree_entry_to_baseindexentry(theirs, 0))
                elif ((ours[0] != base[0]) or (ours[1] != base[1])):
                    out_append(_tree_entry_to_baseindexentry(base, 1))
                    out_append(_tree_entry_to_baseindexentry(ours, 2))
            elif (theirs is None):
                pass
            elif ((theirs[0] != base[0]) or (theirs[1] != base[1])):
                out_append(_tree_entry_to_baseindexentry(base, 1))
                out_append(_tree_entry_to_baseindexentry(theirs, 3))
        elif (ours is None):
            out_append(_tree_entry_to_baseindexentry(theirs, 0))
        elif (theirs is None):
            out_append(_tree_entry_to_baseindexentry(ours, 0))
        elif ((ours[0] != theirs[0]) or (ours[1] != theirs[1])):
            out_append(_tree_entry_to_baseindexentry(ours, 2))
            out_append(_tree_entry_to_baseindexentry(theirs, 3))
        else:
            out_append(_tree_entry_to_baseindexentry(ours, 0))
    return out
