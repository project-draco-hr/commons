def write_tree_from_cache(entries, odb, sl, si=0):
    'Create a tree from the given sorted list of entries and put the respective\n\ttrees into the given object database\n\t\n\t:param entries: **sorted** list of IndexEntries\n\t:param odb: object database to store the trees in\n\t:param si: start index at which we should start creating subtrees\n\t:param sl: slice indicating the range we should process on the entries list\n\t:return: tuple(binsha, list(tree_entry, ...)) a tuple of a sha and a list of \n\t\ttree entries being a tuple of hexsha, mode, name'
    tree_items = list()
    tree_items_append = tree_items.append
    ci = sl.start
    end = sl.stop
    while (ci < end):
        entry = entries[ci]
        if (entry.stage != 0):
            raise UnmergedEntriesError(entry)
        ci += 1
        rbound = entry.path.find('/', si)
        if (rbound == (-1)):
            tree_items_append((entry.binsha, entry.mode, entry.path[si:]))
        else:
            base = entry.path[si:rbound]
            xi = ci
            while (xi < end):
                oentry = entries[xi]
                orbound = oentry.path.find('/', si)
                if ((orbound == (-1)) or (oentry.path[si:orbound] != base)):
                    break
                xi += 1
            (sha, tree_entry_list) = write_tree_from_cache(entries, odb, slice((ci - 1), xi), (rbound + 1))
            tree_items_append((sha, S_IFDIR, base))
            ci = xi
    sio = StringIO()
    tree_to_stream(tree_items, sio.write)
    sio.seek(0)
    istream = odb.store(IStream(str_tree_type, len(sio.getvalue()), sio))
    return (istream.binsha, tree_items)
