def test_base(self):
    rlp_head = fixture_path('reflog_HEAD')
    rlp_master = fixture_path('reflog_master')
    tdir = tempfile.mktemp(suffix='test_reflogs')
    os.mkdir(tdir)
    rlp_master_ro = RefLog.path(self.rorepo.heads.master)
    assert os.path.isfile(rlp_master_ro)
    reflog = RefLog.from_file(rlp_master_ro)
    assert (reflog._path is not None)
    assert isinstance(reflog, RefLog)
    assert len(reflog)
    assert len(list(RefLog.iter_entries(open(rlp_master))))
    assert len(list(RefLog.iter_entries(rlp_master)))
    pp = 'reflog_invalid_'
    for suffix in ('oldsha', 'newsha', 'email', 'date', 'sep'):
        self.failUnlessRaises(ValueError, RefLog.from_file, fixture_path((pp + suffix)))
    self.failUnlessRaises(ValueError, RefLog().write)
    binsha = (chr(255) * 20)
    msg = 'my reflog message'
    cr = self.rorepo.config_reader()
    for rlp in (rlp_head, rlp_master):
        reflog = RefLog.from_file(rlp)
        tfile = os.path.join(tdir, os.path.basename(rlp))
        reflog.to_file(tfile)
        assert (reflog.write() is reflog)
        treflog = RefLog.from_file(tfile)
        assert (treflog == reflog)
        assert (open(tfile).read() == open(rlp).read())
        entry = RefLog.append_entry(cr, tfile, IndexObject.NULL_BIN_SHA, binsha, msg)
        assert (entry.oldhexsha == IndexObject.NULL_HEX_SHA)
        assert (entry.newhexsha == ('f' * 40))
        assert (entry.message == msg)
        assert (RefLog.from_file(tfile)[(-1)] == entry)
        self.failUnlessRaises(IndexError, RefLog.entry_at, rlp, 10000)
        assert isinstance(RefLog.entry_at(rlp, 0), RefLogEntry)
        RefLog.entry_at(rlp, 23)
        for idx in ((-1), (-24)):
            RefLog.entry_at(rlp, idx)
    shutil.rmtree(tdir)
