{
  if (skipPath.apply(jarPath)) {
    listener.onSkip(Optional.<Entry>absent(),itemEntries);
    return Optional.absent();
  }
  if (itemEntries.size() < 2) {
    ReadableEntry entry=Iterables.getOnlyElement(itemEntries);
    listener.onWrite(entry);
    return Optional.of(entry);
  }
  DuplicateAction action=duplicateHandler.actionFor(jarPath);
switch (action) {
case SKIP:
    ReadableEntry original=Iterables.get(itemEntries,0);
  listener.onSkip(Optional.of(original),Iterables.skip(itemEntries,1));
return Optional.of(original);
case REPLACE:
ReadableEntry replacement=Iterables.getLast(itemEntries);
listener.onReplace(Iterables.limit(itemEntries,itemEntries.size() - 1),replacement);
return Optional.of(replacement);
case CONCAT:
InputSupplier<InputStream> concat=ByteStreams.join(Iterables.transform(itemEntries,ReadableEntry.GET_CONTENTS));
ReadableEntry concatenatedEntry=new ReadableEntry(NamedInputSupplier.create(memorySource(),jarPath,concat),jarPath);
listener.onConcat(jarPath,itemEntries);
return Optional.of(concatenatedEntry);
case THROW:
throw new DuplicateEntryException(Iterables.get(itemEntries,1));
default :
throw new IllegalArgumentException("Unrecognized DuplicateAction " + action);
}
}
