def execute(self, targets):
    'Resolves the specified confs for the configured targets and returns an iterator over\n    tuples of (conf, jar path).\n    '

    def dirname_for_requested_targets(targets):
        'Where we put the classpath file for this set of targets.'
        sha = hashlib.sha1()
        for t in targets:
            sha.update(t.id)
        return sha.hexdigest()

    def is_classpath(target):
        return (is_jar(target) or (is_internal(target) and any((jar for jar in target.jar_dependencies if jar.rev))))
    groups = self.context.products.get_data('exclusives_groups')
    for group_key in groups.get_group_keys():
        group_targets = (groups.get_targets_for_group_key(group_key) & set(targets))
        classpath_targets = OrderedSet()
        for target in group_targets:
            classpath_targets.update(filter(is_classpath, filter(is_concrete, target.resolve())))
        if (len(classpath_targets) == 0):
            continue
        target_workdir = os.path.join(self._work_dir, dirname_for_requested_targets(group_targets))
        target_classpath_file = os.path.join(target_workdir, 'classpath')
        with self.invalidated(classpath_targets, only_buildfiles=True, invalidate_dependents=True) as invalidation_check:
            if (invalidation_check.invalid_vts or (not os.path.exists(target_classpath_file))):
                self._exec_ivy(target_workdir, targets, (['-cachepath', target_classpath_file, '-confs'] + self._confs))
                if (not os.path.exists(target_classpath_file)):
                    raise TaskError(('Ivy failed to create classpath file at %s %s' % target_classpath_file))
                if (self.get_artifact_cache() and self.context.options.write_to_artifact_cache):
                    global_vts = VersionedTargetSet.from_versioned_targets(invalidation_check.all_vts)
                    self.update_artifact_cache([(global_vts, [target_classpath_file])])
        with self._cachepath(target_classpath_file) as classpath:
            for path in classpath:
                if self._map_jar(path):
                    for conf in self._confs:
                        groups.update_compatible_classpaths(group_key, [(conf, path.strip())])
    if self._report:
        self._generate_ivy_report()
    if self.context.products.isrequired('ivy_jar_products'):
        self._populate_ivy_jar_products()
    create_jardeps_for = self.context.products.isrequired(self._mapfor_typename())
    if create_jardeps_for:
        genmap = self.context.products.get(self._mapfor_typename())
        for target in filter(create_jardeps_for, targets):
            self._mapjars(genmap, target)
