def split(self, splits):
    "Split the analysis according to splits, which is a list of K iterables of source files.\n\n    Returns a list of K+1 Analysis objects: One for each of the K splits, in order, and one\n    'catch-all' containing the analysis for any remainder sources not mentioned in the K splits.\n    "
    splits = [set(x) for x in splits]
    all_sources = set(itertools.chain(*[self.stamps.sources.iterkeys()])).difference(*splits)
    splits.append(all_sources)
    src_prod_splits = Util.split_dict(self.relations.src_prod, splits)
    binary_dep_splits = Util.split_dict(self.relations.binary_dep, splits)
    classes_splits = Util.split_dict(self.relations.classes, splits)
    representatives = dict(((k, min(vs)) for (k, vs) in self.relations.classes.iteritems()))

    def split_dependencies(all_internal, all_external):
        naive_internals = Util.split_dict(all_internal, splits)
        naive_externals = Util.split_dict(all_external, splits)
        internals = []
        externals = []
        for (naive_internal, external, split) in zip(naive_internals, naive_externals, splits):
            internal = defaultdict(list)
            for (k, vs) in naive_internal.iteritems():
                for v in vs:
                    if (v in split):
                        internal[k].append(v)
                    else:
                        external[k].append(representatives[v])
            internals.append(internal)
            externals.append(external)
        return (internals, externals)
    (internal_splits, external_splits) = split_dependencies(self.relations.internal_src_dep, self.relations.external_dep)
    (internal_pi_splits, external_pi_splits) = split_dependencies(self.relations.internal_src_dep_pi, self.relations.external_dep_pi)
    relations_splits = []
    for args in zip(src_prod_splits, binary_dep_splits, internal_splits, external_splits, internal_pi_splits, external_pi_splits, classes_splits):
        relations_splits.append(Relations(args))
    stamps_splits = []
    for (src_prod, binary_dep, split) in zip(src_prod_splits, binary_dep_splits, splits):
        products_set = set(itertools.chain(*src_prod.values()))
        binaries_set = set(itertools.chain(*binary_dep.values()))
        products = dict(((k, v) for (k, v) in self.stamps.products.iteritems() if (k in products_set)))
        sources = dict(((k, v) for (k, v) in self.stamps.sources.iteritems() if (k in split)))
        binaries = dict(((k, v) for (k, v) in self.stamps.binaries.iteritems() if (k in binaries_set)))
        classnames = dict(((k, v) for (k, v) in self.stamps.classnames.iteritems() if (k in binaries_set)))
        stamps_splits.append(Stamps((products, sources, binaries, classnames)))
    naive_internal_api_splits = Util.split_dict(self.apis.internal, splits)
    naive_external_api_splits = Util.split_dict(self.apis.external, splits)
    internal_api_splits = []
    external_api_splits = []
    for (naive_internal_apis, external_apis, split) in zip(naive_internal_api_splits, naive_external_api_splits, splits):
        internal_apis = defaultdict(list)
        for (k, vs) in naive_internal_apis.iteritems():
            if (k in split):
                internal_apis[k] = vs
            else:
                external_apis[representatives[k]] = vs
        internal_api_splits.append(internal_apis)
        external_api_splits.append(external_apis)
    apis_splits = []
    for args in zip(internal_api_splits, external_api_splits):
        apis_splits.append(APIs(args))
    source_info_splits = [SourceInfos((x,)) for x in Util.split_dict(self.source_infos.source_infos, splits)]
    analyses = []
    for (relations, stamps, apis, source_infos) in zip(relations_splits, stamps_splits, apis_splits, source_info_splits):
        analyses.append(Analysis(relations, stamps, apis, source_infos, self.compilations, self.compile_setup))
    return analyses
