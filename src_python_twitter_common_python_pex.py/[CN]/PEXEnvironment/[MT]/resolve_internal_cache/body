@classmethod
def resolve_internal_cache(cls, pex, pex_info):
    if (os.path.exists(os.path.join(pex, pex_info.internal_cache)) or (not pex_info.always_write_cache)):
        return os.path.join(pex, pex_info.internal_cache)
    with contextlib.closing(zipfile.ZipFile(pex)) as zf:
        for zi in zf.infolist():
            if (zi.filename.endswith('/') or (not zi.filename.startswith(pex_info.internal_cache))):
                continue
            relpath = os.path.relpath(zi.filename, pex_info.internal_cache)
            target_path = os.path.join(pex_info.egg_install_cache, relpath)
            if (os.path.exists(target_path) and (os.path.getsize(target_path) == zi.file_size)):
                continue
            safe_mkdir(os.path.dirname(target_path))
            with TRACER.timed(('Extracting %s' % target_path)):
                with open((target_path + '~'), 'wb') as dst_fp:
                    with contextlib.closing(zf.open(zi.filename)) as src_fp:
                        shutil.copyfileobj(src_fp, dst_fp)
            os.rename((target_path + '~'), target_path)
        return pex_info.egg_install_cache
