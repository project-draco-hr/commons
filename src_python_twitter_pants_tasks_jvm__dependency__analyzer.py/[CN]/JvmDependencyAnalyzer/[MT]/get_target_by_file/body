def get_target_by_file(self):
    'Compute the target_by_file mapping for all targets in-play for this pants run.\n\n    Memoizes for efficiency. Should only be called after codegen, so that all synthetic targets\n    and injected deps are taken into account.\n    '
    if (self._target_by_file is not None):
        return self._target_by_file
    target_by_file = {}
    jarlibs_by_id = {}
    buildroot = get_buildroot()
    for target in self._context.targets():
        if isinstance(target, JvmTarget):
            for src in target.sources:
                target_by_file[os.path.join(buildroot, target.target_base, src)] = target
        elif isinstance(target, JarLibrary):
            for jardep in target.dependencies:
                if isinstance(jardep, JarDependency):
                    jarlibs_by_id[(jardep.org, jardep.name)] = target
    genmap = self._context.products.get('classes')
    for (tgt, products) in genmap.itermappings():
        if isinstance(tgt, JvmTarget):
            for (basedir, classes) in products.items():
                for cls in classes:
                    target_by_file[os.path.join(basedir, cls)] = tgt
    ivy_products = self._context.products.get('ivy_jar_products').get('ivy')
    if ivy_products:
        for ivy_report_list in ivy_products.values():
            for report in ivy_report_list:
                for ref in report.modules_by_ref:
                    target_key = (ref.org, ref.name)
                    if (target_key in jarlibs_by_id):
                        jarlib_target = jarlibs_by_id[target_key]
                        for jar in report.modules_by_ref[ref].artifacts:
                            target_by_file[jar.path] = jarlib_target
        self._target_by_file = target_by_file
    return target_by_file
