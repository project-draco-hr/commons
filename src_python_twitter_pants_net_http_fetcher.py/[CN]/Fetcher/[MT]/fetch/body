def fetch(self, url, listener, chunk_size=None, timeout=None):
    'Fetches data from the given URL notifying listener of all lifecycle events.\n\n    :param string url: the url to GET data from\n    :param listener: the listener to notify of all download lifecycle events\n    :param chunk_size: the chunk size to use for buffering data, 10 KB by default\n    :param timeout: the maximum time to wait for data to be available, 1 second by default\n    :raises: Fetcher.Error if there was a problem fetching all data from the given url\n    '
    chunk_size = (chunk_size or Amount(10, Data.KB))
    if ((not isinstance(chunk_size, Amount)) or (not isinstance(chunk_size.unit(), Data))):
        raise ValueError(('chunk_size must be a Data Amount, given %s' % chunk_size))
    timeout = (timeout or Amount(1, Time.SECONDS))
    if ((not isinstance(timeout, Amount)) or (not isinstance(timeout.unit(), Time))):
        raise ValueError(('chunk_size must be a Time Amount, given %s' % timeout))
    if (not isinstance(listener, self.Listener)):
        raise ValueError(('listener must be a Listener instance, given %s' % listener))
    try:
        with closing(self._requests.get(url, stream=True, timeout=timeout.as_(Time.SECONDS))) as resp:
            if (resp.status_code != requests.codes.ok):
                listener.status(resp.status_code)
                raise self.PermanentError(('GET request to %s failed with status code %d' % (url, resp.status_code)), response_code=resp.status_code)
            size = resp.headers.get('content-length')
            listener.status(resp.status_code, content_length=(int(size) if size else None))
            read_bytes = 0
            for data in resp.iter_content(chunk_size=int(chunk_size.as_(Data.BYTES))):
                listener.recv_chunk(data)
                read_bytes += len(data)
            if (size and (read_bytes != int(size))):
                raise self.Error(('Expected %s bytes, read %d' % (size, read_bytes)))
            listener.finished()
    except requests.exceptions.RequestException as e:
        exception_factory = (self.TransientError if isinstance(e, self._TRANSIENT_EXCEPTION_TYPES) else self.PermanentError)
        raise exception_factory(('Problem GETing data from %s: %s' % (url, e)))
