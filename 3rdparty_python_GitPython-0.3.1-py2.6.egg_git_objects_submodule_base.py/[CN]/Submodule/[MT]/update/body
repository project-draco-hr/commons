def update(self, recursive=False, init=True, to_latest_revision=False, progress=None, dry_run=False):
    "Update the repository of this submodule to point to the checkout\n\t\twe point at with the binsha of this instance.\n\t\t\n\t\t:param recursive: if True, we will operate recursively and update child-\n\t\t\tmodules as well.\n\t\t:param init: if True, the module repository will be cloned into place if necessary\n\t\t:param to_latest_revision: if True, the submodule's sha will be ignored during checkout.\n\t\t\tInstead, the remote will be fetched, and the local tracking branch updated.\n\t\t\tThis only works if we have a local tracking branch, which is the case\n\t\t\tif the remote repository had a master branch, or of the 'branch' option \n\t\t\twas specified for this submodule and the branch existed remotely\n\t\t:param progress: UpdateProgress instance or None of no progress should be shown\n\t\t:param dry_run: if True, the operation will only be simulated, but not performed.\n\t\t\tAll performed operations are read-only\n\t\t:note: does nothing in bare repositories\n\t\t:note: method is definitely not atomic if recurisve is True\n\t\t:return: self"
    if self.repo.bare:
        return self
    if (progress is None):
        progress = UpdateProgress()
    prefix = ''
    if dry_run:
        prefix = 'DRY-RUN: '
    if dry_run:
        mrepo = None
    try:
        mrepo = self.module()
        rmts = mrepo.remotes
        len_rmts = len(rmts)
        for (i, remote) in enumerate(rmts):
            op = FETCH
            if (i == 0):
                op |= BEGIN
            progress.update(op, i, len_rmts, (prefix + ('Fetching remote %s of submodule %r' % (remote, self.name))))
            if (not dry_run):
                remote.fetch(progress=progress)
            if (i == (len_rmts - 1)):
                op |= END
            progress.update(op, i, len_rmts, (prefix + ('Done fetching remote of submodule %r' % self.name)))
    except InvalidGitRepositoryError:
        if (not init):
            return self
        import git
        module_path = join_path_native(self.repo.working_tree_dir, self.path)
        if ((not dry_run) and os.path.isdir(module_path)):
            try:
                os.rmdir(module_path)
            except OSError:
                raise OSError(('Module directory at %r does already exist and is non-empty' % module_path))
        progress.update((BEGIN | CLONE), 0, 1, (prefix + ('Cloning %s to %s in submodule %r' % (self.url, module_path, self.name))))
        if (not dry_run):
            mrepo = git.Repo.clone_from(self.url, module_path, n=True)
        progress.update((END | CLONE), 0, 1, (prefix + ('Done cloning to %s' % module_path)))
        if (not dry_run):
            try:
                remote_branch = find_first_remote_branch(mrepo.remotes, self.branch_name)
                local_branch = mkhead(mrepo, self.branch_path)
                local_branch.set_object(util.Object(mrepo, self.NULL_BIN_SHA))
                mrepo.head.set_reference(local_branch, logmsg=('submodule: attaching head to %s' % local_branch))
                mrepo.head.ref.set_tracking_branch(remote_branch)
            except IndexError:
                print  >> sys.stderr, ('Warning: Failed to checkout tracking branch %s' % self.branch_path)
            self.repo.config_writer().set_value(sm_section(self.name), 'url', self.url)
    binsha = self.binsha
    hexsha = self.hexsha
    if (mrepo is not None):
        is_detached = mrepo.head.is_detached
    if ((mrepo is not None) and to_latest_revision):
        msg_base = ('Cannot update to latest revision in repository at %r as ' % mrepo.working_dir)
        if (not is_detached):
            rref = mrepo.head.ref.tracking_branch()
            if (rref is not None):
                rcommit = rref.commit
                binsha = rcommit.binsha
                hexsha = rcommit.hexsha
            else:
                print  >> sys.stderr, ("%s a tracking branch was not set for local branch '%s'" % (msg_base, mrepo.head.ref))
        else:
            print  >> sys.stderr, ('%s there was no local tracking branch' % msg_base)
    if ((mrepo is not None) and (mrepo.head.commit.binsha != binsha)):
        progress.update((BEGIN | UPDWKTREE), 0, 1, (prefix + ('Updating working tree at %s for submodule %r to revision %s' % (self.path, self.name, hexsha))))
        if (not dry_run):
            if is_detached:
                mrepo.git.checkout(hexsha, force=True)
            else:
                mrepo.head.reset(hexsha, index=True, working_tree=True)
        progress.update((END | UPDWKTREE), 0, 1, (prefix + ('Done updating working tree for submodule %r' % self.name)))
    if recursive:
        if (mrepo is not None):
            for submodule in self.iter_items(self.module()):
                submodule.update(recursive, init, to_latest_revision, progress=progress, dry_run=dry_run)
    return self
