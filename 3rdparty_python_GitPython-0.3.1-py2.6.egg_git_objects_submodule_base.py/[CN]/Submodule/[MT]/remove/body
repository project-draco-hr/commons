@unbare_repo
def remove(self, module=True, force=False, configuration=True, dry_run=False):
    "Remove this submodule from the repository. This will remove our entry\n\t\tfrom the .gitmodules file and the entry in the .git/config file.\n\t\t\n\t\t:param module: If True, the module we point to will be deleted \n\t\t\tas well. If the module is currently on a commit which is not part \n\t\t\tof any branch in the remote, if the currently checked out branch \n\t\t\tworking tree, or untracked files,\n\t\t\tis ahead of its tracking branch,  if you have modifications in the\n\t\t\tIn case the removal of the repository fails for these reasons, the \n\t\t\tsubmodule status will not have been altered.\n\t\t\tIf this submodule has child-modules on its own, these will be deleted\n\t\t\tprior to touching the own module.\n\t\t:param force: Enforces the deletion of the module even though it contains \n\t\t\tmodifications. This basically enforces a brute-force file system based\n\t\t\tdeletion.\n\t\t:param configuration: if True, the submodule is deleted from the configuration, \n\t\t\totherwise it isn't. Although this should be enabled most of the times, \n\t\t\tthis flag enables you to safely delete the repository of your submodule.\n\t\t:param dry_run: if True, we will not actually do anything, but throw the errors\n\t\t\twe would usually throw\n\t\t:return: self\n\t\t:note: doesn't work in bare repositories\n\t\t:raise InvalidGitRepositoryError: thrown if the repository cannot be deleted\n\t\t:raise OSError: if directories or files could not be removed"
    if (not (module + configuration)):
        raise ValueError('Need to specify to delete at least the module, or the configuration')
    if (module and self.module_exists()):
        if force:
            mp = self.abspath
            method = None
            if os.path.islink(mp):
                method = os.remove
            elif os.path.isdir(mp):
                method = shutil.rmtree
            elif os.path.exists(mp):
                raise AssertionError('Cannot forcibly delete repository as it was neither a link, nor a directory')
            if (not dry_run):
                assert method
                method(mp)
        else:
            mod = self.module()
            if mod.is_dirty(untracked_files=True):
                raise InvalidGitRepositoryError(('Cannot delete module at %s with any modifications, unless force is specified' % mod.working_tree_dir))
            for remote in mod.remotes:
                num_branches_with_new_commits = 0
                rrefs = remote.refs
                for rref in rrefs:
                    num_branches_with_new_commits = (len(mod.git.cherry(rref)) != 0)
                if (num_branches_with_new_commits == len(rrefs)):
                    raise InvalidGitRepositoryError(('Cannot delete module at %s as there are new commits' % mod.working_tree_dir))
                if len(rrefs):
                    del rref
                del rrefs
                del remote
            for sm in self.children():
                sm.remove(module=True, force=False, configuration=False, dry_run=dry_run)
                del sm
            if (not dry_run):
                wtd = mod.working_tree_dir
                del mod
                shutil.rmtree(wtd)
    if (configuration and (not dry_run)):
        index = self.repo.index
        try:
            del index.entries[index.entry_key(self.path, 0)]
        except KeyError:
            pass
        index.write()
        self.repo.config_writer().remove_section(sm_section(self.name))
        self.config_writer().remove_section()
    self._clear_cache()
    return self
