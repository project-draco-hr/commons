@unbare_repo
def move(self, module_path, configuration=True, module=True):
    'Move the submodule to a another module path. This involves physically moving\n\t\tthe repository at our current path, changing the configuration, as well as\n\t\tadjusting our index entry accordingly.\n\t\t\n\t\t:param module_path: the path to which to move our module, given as\n\t\t\trepository-relative path. Intermediate directories will be created\n\t\t\taccordingly. If the path already exists, it must be empty.\n\t\t\tTrailling (back)slashes are removed automatically\n\t\t:param configuration: if True, the configuration will be adjusted to let \n\t\t\tthe submodule point to the given path.\n\t\t:param module: if True, the repository managed by this submodule\n\t\t\twill be moved, not the configuration. This will effectively \n\t\t\tleave your repository in an inconsistent state unless the configuration\n\t\t\tand index already point to the target location.\n\t\t:return: self\n\t\t:raise ValueError: if the module path existed and was not empty, or was a file\n\t\t:note: Currently the method is not atomic, and it could leave the repository\n\t\t\tin an inconsistent state if a sub-step fails for some reason\n\t\t'
    if ((module + configuration) < 1):
        raise ValueError('You must specify to move at least the module or the configuration of the submodule')
    module_path = to_native_path_linux(module_path)
    if module_path.endswith('/'):
        module_path = module_path[:(-1)]
    if (module_path == self.path):
        return self
    dest_path = join_path_native(self.repo.working_tree_dir, module_path)
    if os.path.isfile(dest_path):
        raise ValueError(('Cannot move repository onto a file: %s' % dest_path))
    index = self.repo.index
    tekey = index.entry_key(module_path, 0)
    if (configuration and (tekey in index.entries)):
        raise ValueError('Index entry for target path did alredy exist')
    if module:
        if os.path.exists(dest_path):
            if len(os.listdir(dest_path)):
                raise ValueError('Destination module directory was not empty')
            if os.path.islink(dest_path):
                os.remove(dest_path)
            else:
                os.rmdir(dest_path)
        else:
            pass
    cur_path = self.abspath
    renamed_module = False
    if (module and os.path.exists(cur_path)):
        os.renames(cur_path, dest_path)
        renamed_module = True
    try:
        if configuration:
            try:
                ekey = index.entry_key(self.path, 0)
                entry = index.entries[ekey]
                del index.entries[ekey]
                nentry = git.IndexEntry(((entry[:3] + (module_path,)) + entry[4:]))
                index.entries[tekey] = nentry
            except KeyError:
                raise InvalidGitRepositoryError(("Submodule's entry at %r did not exist" % self.path))
            writer = self.config_writer(index=index)
            writer.set_value('path', module_path)
            self.path = module_path
            del writer
    except Exception:
        if renamed_module:
            os.renames(dest_path, cur_path)
        raise
    return self
