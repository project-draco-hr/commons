@classmethod
def iter_items(cls, repo, parent_commit='HEAD'):
    ':return: iterator yielding Submodule instances available in the given repository'
    pc = repo.commit(parent_commit)
    try:
        parser = cls._config_parser(repo, pc, read_only=True)
    except IOError:
        raise StopIteration
    rt = pc.tree
    for sms in parser.sections():
        n = sm_name(sms)
        p = parser.get_value(sms, 'path')
        u = parser.get_value(sms, 'url')
        b = cls.k_head_default
        if parser.has_option(sms, cls.k_head_option):
            b = parser.get_value(sms, cls.k_head_option)
        index = repo.index
        try:
            sm = rt[p]
        except KeyError:
            try:
                entry = index.entries[index.entry_key(p, 0)]
                sm = Submodule(repo, entry.binsha, entry.mode, entry.path)
            except KeyError:
                raise InvalidGitRepositoryError(('Gitmodule path %r did not exist in revision of parent commit %s' % (p, parent_commit)))
        sm._name = n
        sm._parent_commit = pc
        sm._branch_path = git.Head.to_full_path(b)
        sm._url = u
        yield sm
