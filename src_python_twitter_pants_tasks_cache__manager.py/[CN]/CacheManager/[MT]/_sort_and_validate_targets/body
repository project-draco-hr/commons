def _sort_and_validate_targets(self, targets):
    'Validate each target.\n\n    Returns a topologically ordered set of VersionedTargets, each representing one input target.\n    '
    ordered_targets = self._order_target_list(targets)
    versioned_targets = []
    versioned_targets_by_target = {}
    id_to_hash = {}
    for target in ordered_targets:
        dependency_keys = set()
        if (self._invalidate_dependents and hasattr(target, 'dependencies')):
            for dep in target.dependencies:
                if isinstance(dep, ExternalDependency):
                    dependency_keys.add(dep.cache_key())
                elif isinstance(dep, TargetWithSources):
                    fprint = id_to_hash.get(dep.id, None)
                    if (fprint is None):
                        fprint = self._invalidator.existing_hash(dep.id)
                    if (fprint is not None):
                        dependency_keys.add(fprint)
                elif (isinstance(dep, JarLibrary) or isinstance(dep, Pants)):
                    pass
                else:
                    raise ValueError(('Cannot calculate a cache_key for a dependency: %s' % dep))
        cache_key = self._key_for(target, dependency_keys)
        id_to_hash[target.id] = cache_key.hash
        versioned_target = VersionedTarget(self, target, cache_key)
        versioned_targets.append(versioned_target)
        versioned_targets_by_target[target] = versioned_target
    versioned_target_deps_by_target = {}

    def get_versioned_target_deps_for_target(target):
        versioned_target_deps = set([])
        if hasattr(target, 'dependencies'):
            for dep in target.dependencies:
                for dependency in dep.resolve():
                    if (dependency in versioned_targets_by_target):
                        versioned_target_deps.add(versioned_targets_by_target[dependency])
                    elif (dependency in versioned_target_deps_by_target):
                        versioned_target_deps.update(versioned_target_deps_by_target[dependency])
                    else:
                        versioned_target_deps_by_target[dependency] = get_versioned_target_deps_for_target(dependency)
                        versioned_target_deps.update(versioned_target_deps_by_target[dependency])
        return versioned_target_deps
    for versioned_target in versioned_targets:
        versioned_target.dependencies = get_versioned_target_deps_for_target(versioned_target.target)
    return versioned_targets
