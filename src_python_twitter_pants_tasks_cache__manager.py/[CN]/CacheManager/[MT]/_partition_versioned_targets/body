def _partition_versioned_targets(self, versioned_targets, partition_size_hint):
    'Groups versioned targets so that each group has roughly the same number of sources.\n\n    versioned_targets is a list of VersionedTarget objects  [ vt1, vt2, vt3, vt4, vt5, vt6, ...].\n\n    Returns a list of VersionedTargetSet objects, e.g., [ VT1, VT2, VT3, ...] representing the\n    same underlying targets. E.g., VT1 is the combination of [vt1, vt2, vt3], VT2 is the combination\n    of [vt4, vt5] and VT3 is [vt6].\n\n    The new versioned targets are chosen to have roughly partition_size_hint sources.\n\n    This is useful as a compromise between flat mode, where we build all targets in a\n    single compiler invocation, and non-flat mode, where we invoke a compiler for each target,\n    which may lead to lots of compiler startup overhead. A task can choose instead to build one\n    group at a time.\n    '
    res = []


    class VtGroup(object):

        def __init__(self):
            self.vts = []
            self.total_sources = 0
    current_group = VtGroup()

    def add_to_current_group(vt):
        current_group.vts.append(vt)
        current_group.total_sources += vt.num_sources

    def close_current_group():
        if (len(current_group.vts) > 0):
            new_vt = VersionedTargetSet.from_versioned_targets(current_group.vts)
            res.append(new_vt)
            current_group.vts = []
            current_group.total_sources = 0
    for vt in versioned_targets:
        add_to_current_group(vt)
        if (current_group.total_sources > partition_size_hint):
            if ((current_group.total_sources > (1.5 * partition_size_hint)) and (len(current_group.vts) > 1)):
                current_group.vts.pop()
                close_current_group()
                add_to_current_group(vt)
            else:
                close_current_group()
    close_current_group()
    return res
