def update(self, previous_commit=None, recursive=True, force_remove=False, init=True, to_latest_revision=False, progress=None, dry_run=False):
    "Update the submodules of this repository to the current HEAD commit.\n\t\tThis method behaves smartly by determining changes of the path of a submodules\n\t\trepository, next to changes to the to-be-checked-out commit or the branch to be \n\t\tchecked out. This works if the submodules ID does not change.\n\t\tAdditionally it will detect addition and removal of submodules, which will be handled\n\t\tgracefully.\n\t\t\n\t\t:param previous_commit: If set to a commit'ish, the commit we should use \n\t\t\tas the previous commit the HEAD pointed to before it was set to the commit it points to now. \n\t\t\tIf None, it defaults to HEAD@{1} otherwise\n\t\t:param recursive: if True, the children of submodules will be updated as well\n\t\t\tusing the same technique\n\t\t:param force_remove: If submodules have been deleted, they will be forcibly removed.\n\t\t\tOtherwise the update may fail if a submodule's repository cannot be deleted as \n\t\t\tchanges have been made to it (see Submodule.update() for more information)\n\t\t:param init: If we encounter a new module which would need to be initialized, then do it.\n\t\t:param to_latest_revision: If True, instead of checking out the revision pointed to \n\t\t\tby this submodule's sha, the checked out tracking branch will be merged with the \n\t\t\tnewest remote branch fetched from the repository's origin\n\t\t:param progress: RootUpdateProgress instance or None if no progress should be sent\n\t\t:param dry_run: if True, operations will not actually be performed. Progress messages\n\t\t\twill change accordingly to indicate the WOULD DO state of the operation."
    if self.repo.bare:
        raise InvalidGitRepositoryError('Cannot update submodules in bare repositories')
    if (progress is None):
        progress = RootUpdateProgress()
    prefix = ''
    if dry_run:
        prefix = 'DRY-RUN: '
    repo = self.repo
    cur_commit = repo.head.commit
    if (previous_commit is None):
        try:
            previous_commit = repo.commit(repo.head.log_entry((-1)).oldhexsha)
            if (previous_commit.binsha == previous_commit.NULL_BIN_SHA):
                raise IndexError
        except IndexError:
            previous_commit = cur_commit
    else:
        previous_commit = repo.commit(previous_commit)
    psms = self.list_items(repo, parent_commit=previous_commit)
    sms = self.list_items(repo)
    spsms = set(psms)
    ssms = set(sms)
    rrsm = (spsms - ssms)
    len_rrsm = len(rrsm)
    for (i, rsm) in enumerate(rrsm):
        op = REMOVE
        if (i == 0):
            op |= BEGIN
        progress.update(op, i, len_rrsm, (prefix + ('Removing submodule %r at %s' % (rsm.name, rsm.abspath))))
        rsm._parent_commit = repo.head.commit
        if (not dry_run):
            rsm.remove(configuration=False, module=True, force=force_remove)
        if (i == (len_rrsm - 1)):
            op |= END
        progress.update(op, i, len_rrsm, (prefix + ('Done removing submodule %r' % rsm.name)))
    csms = (spsms & ssms)
    len_csms = len(csms)
    for (i, csm) in enumerate(csms):
        psm = psms[csm.name]
        sm = sms[csm.name]
        if ((sm.path != psm.path) and psm.module_exists()):
            progress.update((BEGIN | PATHCHANGE), i, len_csms, (prefix + ('Moving repository of submodule %r from %s to %s' % (sm.name, psm.abspath, sm.abspath))))
            if (not dry_run):
                psm.move(sm.path, module=True, configuration=False)
            progress.update((END | PATHCHANGE), i, len_csms, (prefix + ('Done moving repository of submodule %r' % sm.name)))
        if sm.module_exists():
            if (sm.url != psm.url):
                nn = '__new_origin__'
                smm = sm.module()
                rmts = smm.remotes
                if (len([r for r in rmts if (r.url == sm.url)]) == 0):
                    progress.update((BEGIN | URLCHANGE), i, len_csms, (prefix + ('Changing url of submodule %r from %s to %s' % (sm.name, psm.url, sm.url))))
                    if (not dry_run):
                        assert (nn not in [r.name for r in rmts])
                        smr = smm.create_remote(nn, sm.url)
                        smr.fetch(progress=progress)
                        if (len([r for r in smr.refs if (r.remote_head == sm.branch_name)]) == 0):
                            raise ValueError(('Submodule branch named %r was not available in new submodule remote at %r' % (sm.branch_name, sm.url)))
                        rmt_for_deletion = None
                        for remote in rmts:
                            if (remote.url == psm.url):
                                rmt_for_deletion = remote
                                break
                        if (rmt_for_deletion is None):
                            if (len(rmts) == 1):
                                rmt_for_deletion = rmts[0]
                            else:
                                raise InvalidGitRepositoryError(("Couldn't find original remote-repo at url %r" % psm.url))
                        orig_name = rmt_for_deletion.name
                        smm.delete_remote(rmt_for_deletion)
                        smr.rename(orig_name)
                        smsha = sm.binsha
                        found = False
                        rref = smr.refs[self.branch_name]
                        for c in rref.commit.traverse():
                            if (c.binsha == smsha):
                                found = True
                                break
                        if (not found):
                            print  >> sys.stderr, ("WARNING: Current sha %s was not contained in the tracking branch at the new remote, setting it the the remote's tracking branch" % sm.hexsha)
                            sm.binsha = rref.commit.binsha
                    progress.update((END | URLCHANGE), i, len_csms, (prefix + ('Done adjusting url of submodule %r' % sm.name)))
            if (sm.branch_path != psm.branch_path):
                progress.update((BEGIN | BRANCHCHANGE), i, len_csms, (prefix + ('Changing branch of submodule %r from %s to %s' % (sm.name, psm.branch_path, sm.branch_path))))
                if (not dry_run):
                    smm = sm.module()
                    smmr = smm.remotes
                    try:
                        tbr = git.Head.create(smm, sm.branch_name, logmsg='branch: Created from HEAD')
                    except OSError:
                        tbr = git.Head(smm, sm.branch_path)
                    tbr.set_tracking_branch(find_first_remote_branch(smmr, sm.branch_name))
                    try:
                        tbr = find_first_remote_branch(smmr, psm.branch_name)
                        if (len(smm.git.cherry(tbr, psm.branch)) == 0):
                            psm.branch.delete(smm, psm.branch)
                    except InvalidGitRepositoryError:
                        pass
                progress.update((END | BRANCHCHANGE), i, len_csms, (prefix + ('Done changing branch of submodule %r' % sm.name)))
    for sm in sms:
        sm.update(recursive=False, init=init, to_latest_revision=to_latest_revision, progress=progress, dry_run=dry_run)
        if recursive:
            if sm.module_exists():
                type(self)(sm.module()).update(recursive=True, force_remove=force_remove, init=init, to_latest_revision=to_latest_revision, progress=progress, dry_run=dry_run)
