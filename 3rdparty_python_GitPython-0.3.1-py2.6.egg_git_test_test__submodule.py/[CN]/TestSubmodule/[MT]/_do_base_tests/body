def _do_base_tests(self, rwrepo):
    'Perform all tests in the given repository, it may be bare or nonbare'
    smm = Submodule(rwrepo, ('\x00' * 20))
    self.failUnlessRaises(AttributeError, getattr, smm, 'name')
    sms = Submodule.list_items(rwrepo, self.k_subm_current)
    assert (len(sms) == 1)
    sm = sms[0]
    assert (len(Submodule.list_items(rwrepo, self.k_no_subm_tag)) == 0)
    assert (sm.path == 'git/ext/gitdb')
    assert (sm.path != sm.name)
    assert (sm.url == 'git://github.com/gitpython-developers/gitdb.git')
    assert (sm.branch_path == 'refs/heads/master')
    assert (sm.branch_name == 'master')
    assert (sm.parent_commit == rwrepo.head.commit)
    assert (sm.size == 0)
    self.failUnlessRaises(InvalidGitRepositoryError, sm.module)
    self.failUnlessRaises(InvalidGitRepositoryError, getattr, sm, 'branch')
    assert isinstance(sm.branch_path, basestring)
    smold = Submodule.iter_items(rwrepo, self.k_subm_changed).next()
    assert (smold.binsha != sm.binsha)
    assert (smold != sm)
    del smold._url
    (smold.url == sm.url)
    sm.config_reader()
    new_smclone_path = None
    new_csmclone_path = None
    if rwrepo.bare:
        self.failUnlessRaises(InvalidGitRepositoryError, sm.config_writer)
    else:
        writer = sm.config_writer()
        new_smclone_path = to_native_path_linux(join_path_native(self.rorepo.working_tree_dir, sm.path))
        writer.set_value('url', new_smclone_path)
        del writer
        assert (sm.config_reader().get_value('url') == new_smclone_path)
        assert (sm.url == new_smclone_path)
    smold.config_reader()
    if (not rwrepo.bare):
        self.failUnlessRaises(ValueError, smold.config_writer)
    prev_parent_commit = smold.parent_commit
    self.failUnlessRaises(ValueError, smold.set_parent_commit, self.k_subm_current)
    smold.set_parent_commit((self.k_subm_changed + '~1'))
    assert (smold.binsha != sm.binsha)
    self.failUnlessRaises(ValueError, smold.set_parent_commit, self.k_no_subm_tag)
    if rwrepo.bare:
        self.failUnlessRaises(InvalidGitRepositoryError, sm.module)
        self.failUnlessRaises(InvalidGitRepositoryError, sm.remove)
        self.failUnlessRaises(InvalidGitRepositoryError, sm.add, rwrepo, 'here', 'there')
    else:
        self.failUnlessRaises(InvalidGitRepositoryError, sm.module)
        assert (not sm.module_exists())
        assert (len(list(rwrepo.iter_submodules())) == 1)
        assert (sm.binsha != ('\x00' * 20))
        sma = Submodule.add(rwrepo, sm.name, sm.path)
        assert (sma.path == sm.path)
        self.failUnlessRaises(ValueError, Submodule.add, rwrepo, 'newsubm', 'pathtorepo', url=None)
        newdir = os.path.join(sm.abspath, 'dir')
        os.makedirs(newdir)
        self.failUnlessRaises(OSError, sm.update)
        os.rmdir(newdir)
        sm.update(dry_run=True, progress=prog)
        assert (not sm.module_exists())
        assert (sm.update() is sm)
        sm_repopath = sm.path
        assert sm.module_exists()
        assert isinstance(sm.module(), git.Repo)
        assert (sm.module().working_tree_dir == sm.abspath)
        self.failUnlessRaises(ValueError, Submodule.add, rwrepo, 'newsubm', sm.path, 'git://someurl/repo.git')
        assert (sm.module().head.ref.tracking_branch() is not None)
        shutil.rmtree(sm.abspath)
        assert (len(sm.children()) == 0)
        sm.update(dry_run=True, recursive=False, progress=prog)
        assert (len(sm.children()) == 0)
        sm.update(recursive=False)
        assert (len(list(rwrepo.iter_submodules())) == 2)
        assert (len(sm.children()) == 1)
        csm = sm.children()[0]
        assert (not csm.module_exists())
        csm_repopath = csm.path
        new_csmclone_path = to_native_path_linux(join_path_native(self.rorepo.working_tree_dir, sm.path, csm.path))
        csm.config_writer().set_value('url', new_csmclone_path)
        assert (csm.url == new_csmclone_path)
        assert (not csm.module_exists())
        sm.update(recursive=True, dry_run=True, progress=prog)
        assert (not csm.module_exists())
        sm.update(recursive=True)
        assert csm.module_exists()
        (csm.module().head.ref.tracking_branch() is not None)
        assert (len(list(rwrepo.iter_submodules())) == 2)
        smods = (sm.module(), csm.module())
        for repo in smods:
            repo.head.reset('HEAD~2', working_tree=1)
        sm.update(recursive=True, dry_run=True, progress=prog)
        for repo in smods:
            assert (repo.head.commit != repo.head.ref.tracking_branch().commit)
        sm.update(recursive=True, to_latest_revision=True)
        for repo in smods:
            assert (repo.head.commit == repo.head.ref.tracking_branch().commit)
        del smods
        smref = sm.module().head.ref
        sm.module().head.ref = 'HEAD~1'
        csm_tracking_branch = csm.module().head.ref.tracking_branch()
        csm.module().head.ref.set_tracking_branch(None)
        sm.update(recursive=True, to_latest_revision=True)
        csm.set_parent_commit(csm.repo.head.commit)
        sm.module().head.ref = smref
        csm.module().head.ref.set_tracking_branch(csm_tracking_branch)
        self.failUnlessRaises(ValueError, csm.remove, module=False, configuration=False)
        csm.set_parent_commit(csm.repo.head.commit)
        sm.config_writer().set_value('somekey', 'somevalue')
        csm.config_writer().set_value('okey', 'ovalue')
        self.failUnlessRaises(InvalidGitRepositoryError, sm.remove)
        sm.module().index.reset()
        self.failUnlessRaises(InvalidGitRepositoryError, sm.remove, dry_run=True)
        sm.module().index.reset(working_tree=True)
        assert (sm.remove(dry_run=True) is sm)
        assert sm.module_exists()
        sm.remove(force=True, dry_run=True)
        assert sm.module_exists()
        fn = join_path_native(csm.module().working_tree_dir, 'newfile')
        open(fn, 'w').write('hi')
        self.failUnlessRaises(InvalidGitRepositoryError, sm.remove)
        assert (csm.remove(force=True) is csm)
        assert (not csm.exists())
        assert (not csm.module_exists())
        assert (len(sm.children()) == 0)
        sm.module().index.reset(working_tree=True)
        assert sm.module_exists()
        sm.remove(configuration=False)
        assert sm.exists()
        assert (not sm.module_exists())
        assert sm.config_reader().get_value('url')
        sm.remove()
        assert (not sm.exists())
        assert (not sm.module_exists())
        assert (len(rwrepo.submodules) == 0)
        smid = 'newsub'
        osmid = 'othersub'
        nsm = Submodule.add(rwrepo, smid, sm_repopath, (new_smclone_path + '/'), None, no_checkout=True)
        assert (nsm.name == smid)
        assert nsm.module_exists()
        assert nsm.exists()
        assert (not os.path.isfile(join_path_native(nsm.module().working_tree_dir, Submodule.k_modules_file)))
        assert (len(rwrepo.submodules) == 1)
        osm = Submodule.add(rwrepo, osmid, csm_repopath, new_csmclone_path, Submodule.k_head_default)
        assert (osm != nsm)
        assert osm.module_exists()
        assert osm.exists()
        assert os.path.isfile(join_path_native(osm.module().working_tree_dir, 'setup.py'))
        assert (len(rwrepo.submodules) == 2)
        rwrepo.index.commit('my submod commit')
        assert (len(rwrepo.submodules) == 2)
        nsm.set_parent_commit(rwrepo.head.commit)
        osm.set_parent_commit(rwrepo.head.commit)
        self.failUnlessRaises(ValueError, nsm.move, 'doesntmatter', module=False, configuration=False)
        assert (nsm.move(sm.path) is nsm)
        nmp = (join_path_native('new', 'module', 'dir') + '/')
        pmp = nsm.path
        abspmp = nsm.abspath
        assert (nsm.move(nmp) is nsm)
        nmp = nmp[:(-1)]
        assert (nsm.path == nmp)
        assert (rwrepo.submodules[0].path == nmp)
        mpath = 'newsubmodule'
        absmpath = join_path_native(rwrepo.working_tree_dir, mpath)
        open(absmpath, 'w').write('')
        self.failUnlessRaises(ValueError, nsm.move, mpath)
        os.remove(absmpath)
        nsm.move(pmp)
        assert (nsm.path == pmp)
        assert (rwrepo.submodules[0].path == pmp)
        osmod = osm.module()
        osm.remove(module=False)
        for remote in osmod.remotes:
            remote.remove(osmod, remote.name)
        assert (not osm.exists())
        self.failUnlessRaises(ValueError, Submodule.add, rwrepo, osmid, csm_repopath, url=None)
    self.failUnlessRaises(IOError, Submodule._config_parser, rwrepo, rwrepo.commit(self.k_no_subm_tag), True)
