def _resolve_paths(self, rel_base, paths):
    '\n      Resolves paths relative to the given rel_base from the build root.\n      For example:\n        target: ~/workspace/src/java/com/twitter/common/base/BUILD\n        rel_base: src/resources\n\n      Resolves paths from:\n        ~/workspace/src/resources/com/twitter/common/base\n    '
    if ((not paths) or self.is_meta):
        return paths

    def flatten_paths(*items):
        'Flattens one or more items into a list.  If the item is iterable each of its items is\n      flattened.  If an item is callable, it is called and the result is flattened.  Otherwise the\n      atom is appended to the flattened list.  These rules are applied recursively such that the\n      returned list will only contain non-iterable, non-callable atoms.'
        flat = []

        def flatmap(item):
            if isinstance(item, Compatibility.string):
                flat.append(item)
            else:
                try:
                    for i in iter(item):
                        flatmap(i)
                except:
                    if callable(item):
                        flatmap(item())
                    else:
                        flat.append(item)
        for item in items:
            flatmap(item)
        return flat
    src_relpath = os.path.relpath(self.address.buildfile.parent_path, os.path.join(get_buildroot(), self.target_base))
    resolve_basepath = os.path.join(get_buildroot(), rel_base, src_relpath)
    with pushd(resolve_basepath):
        return [os.path.normpath(os.path.join(src_relpath, path)) for path in flatten_paths(paths)]
