def _resolve_paths(self, paths):
    'Resolves paths.'
    if (not paths):
        return []

    def flatten_paths(*items):
        'Flattens one or more items into a list.\n\n      If the item is iterable each of its items is flattened.  If an item is callable, it is called\n      and the result is flattened.  Otherwise the atom is appended to the flattened list.  These\n      rules are applied recursively such that the returned list will only contain non-iterable,\n      non-callable atoms.\n      '
        flat = []

        def flatmap(item):
            if isinstance(item, Compatibility.string):
                flat.append(item)
            else:
                try:
                    for i in iter(item):
                        flatmap(i)
                except TypeError:
                    if callable(item):
                        flatmap(item())
                    else:
                        flat.append(item)
        for item in items:
            flatmap(item)
        return flat
    src_relpath = os.path.relpath(self.address.buildfile.parent_path, os.path.join(get_buildroot(), self.target_base))
    return [os.path.normpath(os.path.join(src_relpath, path)) for path in flatten_paths(paths)]
