def _resolve_paths(self, rel_base, paths):
    'Resolves paths relative to the given rel_base from the build root.\n\n    For example:\n      target: ~/workspace/src/java/com/twitter/common/base/BUILD\n      rel_base: src/resources\n\n    Resolves paths from:\n      ~/workspace/src/resources/com/twitter/common/base\n    '
    if (not paths):
        return []

    def flatten_paths(*items):
        'Flattens one or more items into a list.\n\n      If the item is iterable each of its items is flattened.  If an item is callable, it is called\n      and the result is flattened.  Otherwise the atom is appended to the flattened list.  These\n      rules are applied recursively such that the returned list will only contain non-iterable,\n      non-callable atoms.\n      '
        flat = []

        def flatmap(item):
            if isinstance(item, Compatibility.string):
                flat.append(item)
            else:
                try:
                    for i in iter(item):
                        flatmap(i)
                except TypeError:
                    if callable(item):
                        flatmap(item())
                    else:
                        flat.append(item)
        for item in items:
            flatmap(item)
        return flat
    src_relpath = os.path.relpath(self.address.buildfile.parent_path, os.path.join(get_buildroot(), self.target_base))
    resolve_basepath = os.path.join(get_buildroot(), rel_base, src_relpath)
    with pushd(resolve_basepath):
        return [os.path.normpath(os.path.join(src_relpath, path)) for path in flatten_paths(paths)]
