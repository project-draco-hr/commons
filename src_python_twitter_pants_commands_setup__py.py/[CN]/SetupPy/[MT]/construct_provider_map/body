@classmethod
def construct_provider_map(cls, root_target):
    "Construct a mapping of provider => minimal target set within :root_target.\n\n       The algorithm works in the following fashion:\n\n         1. Recursively resolve every dependency starting at root_target (the thing\n            that setup_py is being called against).  This includes the dependencies\n            of any binaries attached to the PythonArtifact using with_binaries\n         2. For every PythonTarget that provides a PythonArtifact, add an\n            entry for it to depmap[], keyed on the artifact name, containing\n            an OrderedSet of all transitively resolved children\n            dependencies.\n         3. Any concrete target with sources that is provided by another PythonArtifact\n            other than the one being built with setup_py will be elided.\n\n       Downsides:\n         - Explicitly requested dependencies may be elided if transitively included by others,\n           e.g.\n             python_library(\n               ...,\n               dependencies = [\n                  pants('src/python/twitter/common/dirutil'),\n                  pants('src/python/twitter/common/python'),\n               ]\n            )\n          will result in only twitter.common.python being exported even if top-level sources\n          directly reference twitter.common.dirutil, which could be considered a leak.\n    "
    depmap = defaultdict(OrderedSet)
    cls._construct_provider_map(root_target, root_target, parents=set(), providers=[], depmap=depmap)
    return depmap
