def _parse_progress_line(self, line):
    'Parse progress information from the given line as retrieved by git-push\n\t\tor git-fetch\n\t\t\n\t\t:return: list(line, ...) list of lines that could not be processed'
    self._cur_line = line
    sub_lines = line.split('\r')
    failed_lines = list()
    for sline in sub_lines:
        last_valid_index = None
        for (i, c) in enumerate(reversed(sline)):
            if (ord(c) < 32):
                last_valid_index = ((- i) - 1)
        if (last_valid_index is not None):
            sline = sline[:last_valid_index]
        sline = sline.rstrip()
        (cur_count, max_count) = (None, None)
        match = self.re_op_relative.match(sline)
        if (match is None):
            match = self.re_op_absolute.match(sline)
        if (not match):
            self.line_dropped(sline)
            failed_lines.append(sline)
            continue
        op_code = 0
        (remote, op_name, percent, cur_count, max_count, message) = match.groups()
        if (op_name == 'Counting objects'):
            op_code |= self.COUNTING
        elif (op_name == 'Compressing objects'):
            op_code |= self.COMPRESSING
        elif (op_name == 'Writing objects'):
            op_code |= self.WRITING
        else:
            raise ValueError(('Operation name %r unknown' % op_name))
        if (op_code not in self._seen_ops):
            self._seen_ops.append(op_code)
            op_code |= self.BEGIN
        if (message is None):
            message = ''
        message = message.strip()
        done_token = ', done.'
        if message.endswith(done_token):
            op_code |= self.END
            message = message[:(- len(done_token))]
        self.update(op_code, cur_count, max_count, message)
    return failed_lines
