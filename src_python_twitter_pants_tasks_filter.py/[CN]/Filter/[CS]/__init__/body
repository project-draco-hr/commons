def __init__(self, context, outstream=sys.stdout):
    super(Filter, self).__init__(context, outstream)
    self._filters = []

    def filter_for_address(address):
        match = _get_target(address)
        return (lambda target: (target == match))
    self._filters.extend(_create_filters(context.options.filter_target, filter_for_address))

    def filter_for_type(name):
        try:
            (from_list, module, type_name) = name.rsplit('.', 2)
            module = __import__(('%s.%s' % (from_list, module)), fromlist=[from_list])
            target_type = getattr(module, type_name)
        except (ImportError, ValueError):
            if (not hasattr(twitter.pants, name)):
                raise TaskError(('Invalid type name: %s' % name))
            target_type = getattr(twitter.pants, name)
        if (not issubclass(target_type, Target)):
            raise TaskError(('Not a Target type: %s' % name))
        return (lambda target: isinstance(target, target_type))
    self._filters.extend(_create_filters(context.options.filter_type, filter_for_type))

    def filter_for_ancestor(address):
        ancestor = _get_target(address)
        children = set()
        ancestor.walk(children.add)
        return (lambda target: (target in children))
    self._filters.extend(_create_filters(context.options.filter_ancestor, filter_for_ancestor))

    def filter_for_regex(regex):
        parser = re.compile(regex)
        return (lambda target: parser.search(str(target.address)))
    self._filters.extend(_create_filters(context.options.filter_regex, filter_for_regex))
