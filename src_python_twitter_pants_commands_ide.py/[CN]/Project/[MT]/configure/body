def configure(self):
    "Configures this project's source sets returning the full set of targets the project is\n    comprised of.  The full set can be larger than the initial set of targets when any of the\n    initial targets only has partial ownership of its parent directory source set."
    analyzed = OrderedSet()
    targeted = set()

    def accept_target(target):
        return (has_sources(target) and (not target.is_codegen))

    def configure_source_sets(relative_base, sources, is_test):
        absolute_base = os.path.join(self.root_dir, relative_base)
        paths = set([os.path.dirname(source) for source in sources])
        for path in paths:
            absolute_path = os.path.join(absolute_base, path)
            if (absolute_path not in targeted):
                targeted.add(absolute_path)
                self.sources.append(SourceSet(self.root_dir, relative_base, path, is_test))

    def configure_target(target):
        if (target not in analyzed):
            analyzed.add(target)
            self.has_scala = (self.has_scala or is_scala(target))
            if (isinstance(target, JavaLibrary) or isinstance(target, ScalaLibrary)):
                resources = set()
                if target.resources:
                    resources.update(target.resources)
                if target.binary_resources:
                    resources.update(target.binary_resources)
                if resources:
                    self.resource_extensions.update(Project.extract_resource_extensions(resources))
                    configure_source_sets(ExportableJvmLibrary.RESOURCES_BASE_DIR, resources, is_test=False)
            if target.sources:
                test = is_test(target)
                self.has_tests = (self.has_tests or test)
                configure_source_sets(target.target_base, target.sources, is_test=test)
            siblings = Target.get_all_addresses(target.address.buildfile)
            return filter(accept_target, [Target.get(a) for a in siblings if (a != target.address)])
    for target in self.targets:
        target.walk(configure_target, predicate=accept_target)
    for source_set in self.sources:
        paths = set()
        source_base = os.path.join(self.root_dir, source_set.source_base)
        for (root, dirs, _) in os.walk(os.path.join(source_base, source_set.path)):
            if dirs:
                paths.update([os.path.join(root, dir) for dir in dirs])
        unused_children = (paths - targeted)
        if (unused_children and (paths != unused_children)):
            source_set.excludes.extend((os.path.relpath(child, source_base) for child in unused_children))
    targets = OrderedSet()
    for target in self.targets:
        target.walk((lambda target: targets.add(target)), has_sources)
    targets.update((analyzed - targets))
    return targets
