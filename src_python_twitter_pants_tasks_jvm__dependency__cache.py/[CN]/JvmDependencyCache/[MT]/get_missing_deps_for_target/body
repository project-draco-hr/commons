def get_missing_deps_for_target(self, target, computed_deps, computed_jar_deps, targets_by_class, targets_by_source, error_filter):
    '  Compute the missing dependencies for a specific target.\n\n    Parameters:\n      target: the target\n      computed_deps: the computed dependencies for the target.\n      computed_jar_deps: the computed jar dependencies for the target.\n      targets_by_class: a mapping specifying which classes are produced by which targets.\n      error_filter: function which checks a target identified as a missing dependency,\n        and returns True if that missing dependency should be treated as an error.\n\n    Return:\n      (undeclared_deps, intransitive_undeclared_deps)\n    '
    if (not error_filter(target)):
        return ([], [])
    undeclared_deps = computed_deps.copy()
    undeclared_jar_deps = computed_jar_deps.copy()
    target.walk((lambda target: self._dependency_walk_work(undeclared_deps, undeclared_jar_deps, target)))
    undeclared_deps = filter(error_filter, undeclared_deps)
    intransitive_undeclared_deps = set(filter(error_filter, computed_deps.difference(target.dependencies).difference([target])))
    if (len(undeclared_deps) > 0):
        genmap = self.context.products.get('missing_deps')
        genmap.add(target, self.context._buildroot, [x.derived_from.address.reference() for x in undeclared_deps])
        genmap.add(target, self.context._buildroot)
        for dep_target in undeclared_deps:
            print ('Error: target %s has undeclared compilation dependency on %s,' % (target.address, dep_target.derived_from.address.reference()))
            print ('       because source file %s depends on class %s' % self.get_dependency_blame(target, dep_target, targets_by_class, targets_by_source))
            intransitive_undeclared_deps.discard(dep_target)
    if ((self.check_intransitive_deps is not 'none') and (len(intransitive_undeclared_deps) > 0)):
        genmap = self.context.products.get('missing_intransitive_deps')
        genmap.add(target, self.context._buildroot, [x.derived_from.address.reference() for x in intransitive_undeclared_deps])
        for dep_target in intransitive_undeclared_deps:
            print ('Error: target %s has undeclared intransitive compilation dependency on %s,' % (target.address, dep_target.derived_from.address.reference()))
            print ('       because source file %s depends on class %s' % self.get_dependency_blame(target, dep_target, targets_by_class, targets_by_source))
    return (undeclared_deps, intransitive_undeclared_deps)
