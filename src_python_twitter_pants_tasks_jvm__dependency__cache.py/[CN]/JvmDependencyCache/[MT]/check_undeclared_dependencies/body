def check_undeclared_dependencies(self):
    '\n    Performs the undeclared dependencies/overdeclared dependencies checks,\n    generating warnings/error messages and (depending on flag settings),\n    setting build products for the detected errors.\n    '
    if (not self.check_missing_deps):
        return
    (deps_by_target, jar_deps_by_target) = self.get_compilation_dependencies()
    found_missing_deps = False
    for target in deps_by_target:
        computed_deps = deps_by_target[target]
        computed_jar_deps = jar_deps_by_target[target]
        undeclared_deps = computed_deps.copy()
        undeclared_jar_deps = computed_jar_deps.copy()
        target.walk((lambda target: self._dependency_walk_work(undeclared_deps, undeclared_jar_deps, target)))
        immediate_missing_deps = computed_deps.difference(target.dependencies).difference([target])
        if (len(undeclared_deps) > 0):
            found_missing_deps = True
            genmap = self.task.context.products.get('missing_deps')
            genmap.add(target, self.task.context._buildroot, [x.derived_from.address.reference() for x in undeclared_deps])
            for dep_target in undeclared_deps:
                print ('Error: target %s has undeclared compilation dependency on %s,' % (target.address, dep_target.derived_from.address.reference()))
                print ('       because source file %s depends on class %s' % self.get_dependency_blame(target, dep_target))
                immediate_missing_deps.discard(dep_target)
        if (self.check_intransitive_deps != 'none'):
            if (len(immediate_missing_deps) > 0):
                genmap = self.task.context.products.get('missing_deps')
                if (self.check_intransitive_deps == 'error'):
                    found_missing_deps = True
                    genmap.add(target, self.context._buildroot, [x.derived_from.address.reference() for x in immediate_missing_deps])
                for missing in immediate_missing_deps:
                    print ('Error: target %s depends on %s which is only declared transitively' % (target, missing))
        if self.check_unnecessary_deps:
            overdeps = target.declared_dependencies.difference(computed_deps)
            if (len(overdeps) > 0):
                for d in overdeps:
                    print ('Warning: target %s declares un-needed dependency on: %s' % (target, d))
    if found_missing_deps:
        raise TaskError('Missing dependencies detected.')
