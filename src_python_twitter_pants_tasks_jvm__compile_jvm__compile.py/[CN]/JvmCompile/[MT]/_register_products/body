def _register_products(self, targets, sources_by_target, analysis_file):
    required_data = ['classes_by_source', 'classes_by_target', 'resources_by_target']
    if (not any((self.context.products.is_required_data(x) for x in required_data))):
        return
    make_products = (lambda : defaultdict(MultipleRootedProducts))
    computed_classes_by_source = self._compute_classes_by_source(analysis_file)
    classes_by_source = self.context.products.get_data('classes_by_source', make_products)
    classes_by_target = self.context.products.get_data('classes_by_target', make_products)
    resources_by_target = self.context.products.get_data('resources_by_target', make_products)
    for target in targets:
        target_products = classes_by_target[target]
        for source in sources_by_target[target]:
            classes = computed_classes_by_source.get(source, [])
            target_products.add_abs_paths(self._classes_dir, classes)
            classes_by_source[source].add_abs_paths(self._classes_dir, classes)
        if self.context.products.is_required_data('resources_by_target'):
            target_resources = resources_by_target[target]
            for (root, abs_paths) in self.extra_products(target):
                target_resources.add_abs_paths(root, abs_paths)
