def install_python(home_dir, lib_dir, inc_dir, bin_dir, site_packages, clear):
    'Install just the base environment, no distutils patches etc'
    if sys.executable.startswith(bin_dir):
        print 'Please use the *system* python to run this script'
        return
    if clear:
        rmtree(lib_dir)
        logger.notify('Not deleting %s', bin_dir)
    if hasattr(sys, 'real_prefix'):
        logger.notify(('Using real prefix %r' % sys.real_prefix))
        prefix = sys.real_prefix
    else:
        prefix = sys.prefix
    mkdir(lib_dir)
    fix_lib64(lib_dir)
    fix_local_scheme(home_dir)
    stdlib_dirs = [os.path.dirname(os.__file__)]
    if (sys.platform == 'win32'):
        stdlib_dirs.append(join(os.path.dirname(stdlib_dirs[0]), 'DLLs'))
    elif (sys.platform == 'darwin'):
        stdlib_dirs.append(join(stdlib_dirs[0], 'site-packages'))
    if hasattr(os, 'symlink'):
        logger.info('Symlinking Python bootstrap modules')
    else:
        logger.info('Copying Python bootstrap modules')
    logger.indent += 2
    try:
        for stdlib_dir in stdlib_dirs:
            if (not os.path.isdir(stdlib_dir)):
                continue
            for fn in os.listdir(stdlib_dir):
                bn = os.path.splitext(fn)[0]
                if ((fn != 'site-packages') and (bn in REQUIRED_FILES)):
                    copyfile(join(stdlib_dir, fn), join(lib_dir, fn))
        copy_required_modules(home_dir)
    finally:
        logger.indent -= 2
    mkdir(join(lib_dir, 'site-packages'))
    import site
    site_filename = site.__file__
    if site_filename.endswith('.pyc'):
        site_filename = site_filename[:(-1)]
    elif site_filename.endswith('$py.class'):
        site_filename = site_filename.replace('$py.class', '.py')
    site_filename_dst = change_prefix(site_filename, home_dir)
    site_dir = os.path.dirname(site_filename_dst)
    writefile(site_filename_dst, SITE_PY)
    writefile(join(site_dir, 'orig-prefix.txt'), prefix)
    site_packages_filename = join(site_dir, 'no-global-site-packages.txt')
    if (not site_packages):
        writefile(site_packages_filename, '')
    elif os.path.exists(site_packages_filename):
        logger.info(('Deleting %s' % site_packages_filename))
        os.unlink(site_packages_filename)
    if (is_pypy or is_win):
        stdinc_dir = join(prefix, 'include')
    else:
        stdinc_dir = join(prefix, 'include', (py_version + abiflags))
    if os.path.exists(stdinc_dir):
        copyfile(stdinc_dir, inc_dir)
    else:
        logger.debug(('No include dir %s' % stdinc_dir))
    if ((sys.exec_prefix != prefix) and (not is_pypy)):
        if (sys.platform == 'win32'):
            exec_dir = join(sys.exec_prefix, 'lib')
        elif is_jython:
            exec_dir = join(sys.exec_prefix, 'Lib')
        else:
            exec_dir = join(sys.exec_prefix, 'lib', py_version)
        for fn in os.listdir(exec_dir):
            copyfile(join(exec_dir, fn), join(lib_dir, fn))
    if is_jython:
        for name in ('jython-dev.jar', 'javalib', 'jython.jar'):
            src = join(prefix, name)
            if os.path.exists(src):
                copyfile(src, join(home_dir, name))
        src = join(prefix, 'registry')
        if os.path.exists(src):
            copyfile(src, join(home_dir, 'registry'), symlink=False)
        copyfile(join(prefix, 'cachedir'), join(home_dir, 'cachedir'), symlink=False)
    mkdir(bin_dir)
    py_executable = join(bin_dir, os.path.basename(sys.executable))
    if ('Python.framework' in prefix):
        if re.search('/Python(?:-32|-64)*$', py_executable):
            py_executable = os.path.join(os.path.dirname(py_executable), 'python')
    logger.notify('New %s executable in %s', expected_exe, py_executable)
    if (sys.executable != py_executable):
        executable = sys.executable
        if ((sys.platform == 'cygwin') and os.path.exists((executable + '.exe'))):
            executable += '.exe'
            py_executable += '.exe'
            logger.info(('Executable actually exists in %s' % executable))
        shutil.copyfile(executable, py_executable)
        make_exe(py_executable)
        if ((sys.platform == 'win32') or (sys.platform == 'cygwin')):
            pythonw = os.path.join(os.path.dirname(sys.executable), 'pythonw.exe')
            if os.path.exists(pythonw):
                logger.info('Also created pythonw.exe')
                shutil.copyfile(pythonw, os.path.join(os.path.dirname(py_executable), 'pythonw.exe'))
        if is_pypy:
            python_executable = os.path.join(os.path.dirname(py_executable), 'python')
            logger.info(('Also created executable %s' % python_executable))
            copyfile(py_executable, python_executable)
    if (os.path.splitext(os.path.basename(py_executable))[0] != expected_exe):
        secondary_exe = os.path.join(os.path.dirname(py_executable), expected_exe)
        py_executable_ext = os.path.splitext(py_executable)[1]
        if (py_executable_ext == '.exe'):
            secondary_exe += py_executable_ext
        if os.path.exists(secondary_exe):
            logger.warn(('Not overwriting existing %s script %s (you must use %s)' % (expected_exe, secondary_exe, py_executable)))
        else:
            logger.notify(('Also creating executable in %s' % secondary_exe))
            shutil.copyfile(sys.executable, secondary_exe)
            make_exe(secondary_exe)
    if ('Python.framework' in prefix):
        logger.debug('MacOSX Python framework detected')
        original_python = os.path.join(prefix, 'Resources/Python.app/Contents/MacOS/Python')
        shutil.copy(original_python, py_executable)
        virtual_lib = os.path.join(home_dir, '.Python')
        if os.path.exists(virtual_lib):
            os.unlink(virtual_lib)
        copyfile(os.path.join(prefix, 'Python'), virtual_lib)
        try:
            call_subprocess(['install_name_tool', '-change', os.path.join(prefix, 'Python'), '@executable_path/../.Python', py_executable])
        except:
            logger.fatal("Could not call install_name_tool -- you must have Apple's development tools installed")
            raise
        py_executable_version = ('%s.%s' % (sys.version_info[0], sys.version_info[1]))
        if (not py_executable.endswith(py_executable_version)):
            pth = (py_executable + ('%s.%s' % (sys.version_info[0], sys.version_info[1])))
            if os.path.exists(pth):
                os.unlink(pth)
            os.symlink('python', pth)
        else:
            pth = join(bin_dir, 'python')
            if os.path.exists(pth):
                os.unlink(pth)
            os.symlink(os.path.basename(py_executable), pth)
    if ((sys.platform == 'win32') and (' ' in py_executable)):
        py_executable = ('"%s"' % py_executable)
    cmd = [py_executable, '-c', 'import sys; print(sys.prefix)']
    logger.info(('Testing executable with %s %s "%s"' % tuple(cmd)))
    try:
        proc = subprocess.Popen(cmd, stdout=subprocess.PIPE)
        (proc_stdout, proc_stderr) = proc.communicate()
    except OSError:
        e = sys.exc_info()[1]
        if (e.errno == errno.EACCES):
            logger.fatal(('ERROR: The executable %s could not be run: %s' % (py_executable, e)))
            sys.exit(100)
        else:
            raise e
    proc_stdout = proc_stdout.strip().decode(sys.getdefaultencoding())
    proc_stdout = os.path.normcase(os.path.abspath(proc_stdout))
    if (proc_stdout != os.path.normcase(os.path.abspath(home_dir))):
        logger.fatal(('ERROR: The executable %s is not functioning' % py_executable))
        logger.fatal(('ERROR: It thinks sys.prefix is %r (should be %r)' % (proc_stdout, os.path.normcase(os.path.abspath(home_dir)))))
        logger.fatal('ERROR: virtualenv is not compatible with this system or executable')
        if (sys.platform == 'win32'):
            logger.fatal('Note: some Windows users have reported this error when they installed Python for "Only this user".  The problem may be resolvable if you install Python "For all users".  (See https://bugs.launchpad.net/virtualenv/+bug/352844)')
        sys.exit(100)
    else:
        logger.info(('Got sys.prefix result: %r' % proc_stdout))
    pydistutils = os.path.expanduser('~/.pydistutils.cfg')
    if os.path.exists(pydistutils):
        logger.notify(('Please make sure you remove any previous custom paths from your %s file.' % pydistutils))
    return py_executable
