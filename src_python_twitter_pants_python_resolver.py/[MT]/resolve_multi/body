def resolve_multi(config, requirements, interpreter=None, platforms=None, conn_timeout=None, ttl=3600):
    'Multi-platform dependency resolution for PEX files.\n\n     Given a pants configuration and a set of requirements, return a list of distributions\n     that must be included in order to satisfy them.  That may involve distributions for\n     multiple platforms.\n\n     :param config: Pants :class:`Config` object.\n     :param requirements: A list of :class:`PythonRequirement` objects to resolve.\n     :param interpreter: :class:`PythonInterpreter` for which requirements should be resolved.\n                         If None specified, defaults to current interpreter.\n     :param platforms: Optional list of platforms against requirements will be resolved. If\n                         None specified, the defaults from `config` will be used.\n     :param conn_timeout: Optional connection timeout for any remote fetching.\n     :param ttl: Time in seconds before we consider re-resolving an open-ended requirement, e.g.\n                 "flask>=0.2" if a matching distribution is available on disk.  Defaults\n                 to 3600.\n  '
    now = time.time()
    distributions = {}
    interpreter = (interpreter or PythonInterpreter.get())
    if (not isinstance(interpreter, PythonInterpreter)):
        raise TypeError(('Expected interpreter to be a PythonInterpreter, got %s' % type(interpreter)))
    install_cache = config.get('python-setup', 'install_cache')
    platforms = get_platforms((platforms or config.getlist('python-setup', 'platforms', ['current'])))
    crawler = crawler_from_config(config, conn_timeout=conn_timeout)
    fetchers = fetchers_from_config(config)
    for platform in platforms:
        env = PantsEnvironment(search_path=[], platform=platform, python=interpreter.python)
        working_set = WorkingSet(entries=[])
        shared_options = dict(install_cache=install_cache, platform=platform)
        egg_translator = EggTranslator(python=interpreter.python, **shared_options)
        egg_obtainer = Obtainer(crawler, [Fetcher([install_cache])], egg_translator)

        def installer(req):
            dist = egg_obtainer.obtain(req)
            if (dist and (requirement_is_exact(req) or ((now - os.path.getmtime(dist.location)) < ttl))):
                return dist
            source_translator = SourceTranslator(interpreter=interpreter, use_2to3=getattr(req, 'use_2to3', False), **shared_options)
            translator = ChainedTranslator(egg_translator, source_translator)
            obtainer = Obtainer(crawler, ([Fetcher([req.repository])] if getattr(req, 'repository', None) else fetchers), translator)
            dist = obtainer.obtain(req)
            if dist:
                try:
                    touch(dist.location)
                except OSError:
                    pass
            return dist
        distributions[platform] = working_set.resolve(requirements, env=env, installer=installer)
    return distributions
