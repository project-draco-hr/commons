def _split_classes_dir(self, state, diff):
    'Split the merged classes dir into one dir per underlying artifact.'
    if (len(self.underlying_artifacts) <= 1):
        return

    def map_classes_by_package(classes):
        ret = defaultdict(list)
        for cls in classes:
            ret[os.path.dirname(cls)].append(os.path.basename(cls))
        return ret
    self.log.debug(('Splitting classes dir %s' % self.classes_dir))
    if diff:
        new_or_changed_classnames_by_package = map_classes_by_package(diff.new_or_changed_classes)
        deleted_classnames_by_package = map_classes_by_package(diff.deleted_classes)
    else:
        new_or_changed_classnames_by_package = None
        deleted_classnames_by_package = None
    symlinkable_packages = self._symlinkable_packages(state)
    for artifact in self.underlying_artifacts:
        classnames_by_package = map_classes_by_package(state.classes_by_target.get(artifact.targets[0], []))
        for (package, classnames) in classnames_by_package.items():
            if (package == ''):
                raise TaskError(('Found class files %s with empty package' % classnames))
            artifact_package_dir = os.path.join(artifact.classes_dir, package)
            merged_package_dir = os.path.join(self.classes_dir, package)
            if (package in symlinkable_packages):
                if os.path.islink(merged_package_dir):
                    current_link = os.readlink(merged_package_dir)
                    if (current_link != artifact_package_dir):
                        os.unlink(merged_package_dir)
                        safe_rmtree(artifact_package_dir)
                        shutil.move(current_link, artifact_package_dir)
                        os.symlink(artifact_package_dir, merged_package_dir)
                else:
                    safe_rmtree(artifact_package_dir)
                    shutil.move(merged_package_dir, artifact_package_dir)
                    print ('========> Sylinking %s to %s' % (artifact_package_dir, merged_package_dir))
                    os.symlink(artifact_package_dir, merged_package_dir)
            else:
                safe_mkdir(artifact_package_dir)
                new_or_changed_classnames = (set(new_or_changed_classnames_by_package.get(package, [])) if diff else None)
                for classname in classnames:
                    if ((not diff) or (classname in new_or_changed_classnames)):
                        src = os.path.join(merged_package_dir, classname)
                        dst = os.path.join(artifact_package_dir, classname)
                        self._maybe_hardlink(src, dst)
                if diff:
                    for classname in deleted_classnames_by_package.get(package, []):
                        path = os.path.join(artifact_package_dir, classname)
                        if os.path.exists(path):
                            os.unlink(path)
