def execute(self, targets):
    catalog = self.context.products.isrequired('javadoc')
    if (catalog and self.combined):
        raise TaskError('Cannot provide javadoc target mappings for combined output')
    with self.invalidated(filter(is_java, targets)) as invalidation_check:
        safe_mkdir(self._output_dir)
        with self.context.state('classpath', []) as cp:
            classpath = [jar for (conf, jar) in cp if (conf in self.confs)]

            def find_javadoc_targets():
                invalid_targets = []
                for vt in invalidation_check.invalid_vts:
                    invalid_targets.extend(vt.targets)
                if self.transitive:
                    return invalid_targets
                else:
                    return set(invalid_targets).intersection(set(self.context.target_roots))
            javadoc_targets = list(filter(is_java, find_javadoc_targets()))
            if self.combined:
                self.generate_combined(classpath, javadoc_targets)
            else:
                self.generate_individual(classpath, javadoc_targets)
    if catalog:
        for target in targets:
            gendir = self._gendir(target)
            javadocs = []
            for (root, dirs, files) in os.walk(gendir):
                javadocs.extend((os.path.relpath(os.path.join(root, f), gendir) for f in files))
            self.context.products.get('javadoc').add(target, gendir, javadocs)
