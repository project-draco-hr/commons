@staticmethod
def open(path, zf_path=None, zf=None):
    '\n      Open potentially nested zip archives.\n        path: the path to open, relative to zf (if None, then relative to CWD)\n        zf_path: the path to the current zf (if None, then relative to CWD)\n        zf: the current zipfile\n\n      Returns (archive, suffix, zipfile)\n        archive: the archive name associated with zipfile\n        suffix: the leftover path relative to the zipfile archive\n        zipfile: the zipfile\n    '
    if (path == '.'):
        assert (zf_path is not None)
        assert (zf is not None)
        return (zf_path, '', zf)
    if (zf is None):
        (existing, non_existing) = Nested._split_existing(path)
        next_zf = Nested.get(existing, provider=(lambda : zipfile.ZipFile(existing)))
        return Nested.open(non_existing, zf_path=existing, zf=next_zf)
    else:
        (existing, non_existing) = Nested._split_zf_existing(zf, path)
        get_path = os.path.join(zf_path, existing)
        try:
            next_zf = Nested.get(get_path, provider=(lambda : Nested.open_as(zf, existing)))
            return Nested.open(non_existing, zf_path=get_path, zf=next_zf)
        except (zipfile.BadZipfile, KeyError):
            return (zf_path, path, zf)
