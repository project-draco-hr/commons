def load_module(self, fullmodname):
    "PEP-302-compliant load_module() method.\n\n    Args:\n      fullmodname: The dot-separated full module name, e.g. 'django.core.mail'.\n\n    Returns:\n      The module object constructed from the source code.\n\n    Raises:\n      SyntaxError if the module's source code is syntactically incorrect.\n      ImportError if there was a problem accessing the source code.\n      Whatever else can be raised by executing the module's source code.\n    "
    with self._log_nested(('entering load_module(%s)' % fullmodname), at_level=3):
        (submodname, is_package, fullpath, code) = self._get_code(fullmodname)
        mod = sys.modules.get(fullmodname)
        try:
            if (mod is None):
                mod = sys.modules[fullmodname] = types.ModuleType(fullmodname)
            mod.__loader__ = self
            mod.__file__ = fullpath
            mod.__name__ = fullmodname
            self._log(('** __file__ = %s' % mod.__file__), at_level=4)
            self._log(('** __name__ = %s' % mod.__name__), at_level=4)
            if is_package:
                mod.__path__ = [os.path.dirname(mod.__file__)]
                self._log(('** __path__ = %s' % mod.__path__), at_level=4)
            exec_function(code, mod.__dict__)
        except Exception as e:
            self._log(('Caught exception: %s' % e))
            if (fullmodname in sys.modules):
                del sys.modules[fullmodname]
            raise
    self._log(('exiting load_module(%s) => __file__ = %s, __name__ = %s' % (fullmodname, mod.__file__, mod.__name__)), at_level=3)
    return sys.modules.get(fullmodname)
