@staticmethod
def setup_parser(subcls, option_group, args, mkflag):
    NailgunTask.setup_parser(option_group, args, mkflag)
    option_group.add_option(mkflag('missing-deps'), dest=(subcls._language + '_missing_deps'), choices=['off', 'warn', 'fatal'], default='warn', help=(('[%default] One of off, warn, fatal. Check for missing dependencies in ' + subcls._language) + 'code. Reports actual dependencies A -> B where there is no transitive BUILD file dependency path from A to B.If fatal, missing deps are treated as a build error.'))
    option_group.add_option(mkflag('missing-direct-deps'), dest=(subcls._language + '_missing_direct_deps'), choices=['off', 'warn', 'fatal'], default='off', help=(('[%default] One of off, warn, fatal. Check for missing direct dependencies in ' + subcls._language) + ' code. Reports actual dependencies A -> B where there is no direct BUILD file dependency path from A to B. This is a very strict check, as in practice it is common to rely on transitive, non-direct dependencies, e.g., due to type inference or when the main target in a BUILD file is modified to depend on other targets in the same BUILD file as an implementation detail. It may still be useful to set it to fatal temorarily, to detect these.'))
    option_group.add_option(mkflag('unnecessary-deps'), dest=(subcls._language + '_unnecessary_deps'), choices=['off', 'warn', 'fatal'], default='off', help=(('[%default] One of off, warn, fatal. Check for declared dependencies in ' + subcls._language) + ' code that are not needed. This is a very strict check. For example, generated code will often legitimately have BUILD dependencies that are unused in practice.'))
