@with_rw_repo('0.1.6')
def test_index_mutation(self, rw_repo):
    index = rw_repo.index
    num_entries = len(index.entries)
    cur_head = rw_repo.head
    uname = 'Some Developer'
    umail = 'sd@company.com'
    rw_repo.config_writer().set_value('user', 'name', uname)
    rw_repo.config_writer().set_value('user', 'email', umail)

    def mixed_iterator():
        count = 0
        for entry in index.entries.itervalues():
            type_id = (count % 4)
            if (type_id == 0):
                yield entry.path
            elif (type_id == 1):
                yield Blob(rw_repo, entry.binsha, entry.mode, entry.path)
            elif (type_id == 2):
                yield BaseIndexEntry(entry[:4])
            elif (type_id == 3):
                yield entry
            else:
                raise AssertionError('Invalid Type')
            count += 1
    deleted_files = index.remove(mixed_iterator(), working_tree=False)
    assert deleted_files
    assert (self._count_existing(rw_repo, deleted_files) == len(deleted_files))
    assert (len(index.entries) == 0)
    index.reset()
    assert (len(index.entries) == num_entries)
    deleted_files = index.remove(mixed_iterator(), working_tree=True)
    assert deleted_files
    assert (self._count_existing(rw_repo, deleted_files) == 0)
    index.reset(working_tree=True)
    assert (self._count_existing(rw_repo, deleted_files) == len(deleted_files))
    self.failUnlessRaises(TypeError, index.remove, [1])
    deleted_files = index.remove([os.path.join(rw_repo.working_tree_dir, 'lib')], r=True)
    assert (len(deleted_files) > 1)
    self.failUnlessRaises(ValueError, index.remove, ['/doesnt/exists'])
    cur_commit = cur_head.commit
    commit_message = 'commit default head'
    new_commit = index.commit(commit_message, head=False)
    assert (cur_commit != new_commit)
    assert (new_commit.author.name == uname)
    assert (new_commit.author.email == umail)
    assert (new_commit.committer.name == uname)
    assert (new_commit.committer.email == umail)
    assert (new_commit.message == commit_message)
    assert (new_commit.parents[0] == cur_commit)
    assert (len(new_commit.parents) == 1)
    assert (cur_head.commit == cur_commit)
    commit_message = 'index without parents'
    commit_no_parents = index.commit(commit_message, parent_commits=list(), head=True)
    assert (commit_no_parents.message == commit_message)
    assert (len(commit_no_parents.parents) == 0)
    assert (cur_head.commit == commit_no_parents)
    commit_message = 'Index with multiple parents\n\t   commit with another line'
    commit_multi_parent = index.commit(commit_message, parent_commits=(commit_no_parents, new_commit))
    assert (commit_multi_parent.message == commit_message)
    assert (len(commit_multi_parent.parents) == 2)
    assert (commit_multi_parent.parents[0] == commit_no_parents)
    assert (commit_multi_parent.parents[1] == new_commit)
    assert (cur_head.commit == commit_multi_parent)
    index.reset(new_commit.parents[0], working_tree=True).reset(new_commit, working_tree=False)
    lib_file_path = os.path.join('lib', 'git', '__init__.py')
    assert ((lib_file_path, 0) not in index.entries)
    assert os.path.isfile(os.path.join(rw_repo.working_tree_dir, lib_file_path))
    entries = index.add(['lib'], fprogress=self._fprogress_add)
    self._assert_entries(entries)
    self._assert_fprogress(entries)
    assert (len(entries) > 1)
    entries = index.reset(new_commit).add([os.path.join('lib', 'git', '*.py')], fprogress=self._fprogress_add)
    self._assert_entries(entries)
    self._assert_fprogress(entries)
    assert (len(entries) == 14)
    entries = index.reset(new_commit).add(([os.path.abspath(os.path.join('lib', 'git', 'head.py'))] * 2), fprogress=self._fprogress_add)
    self._assert_entries(entries)
    assert ((entries[0].mode & 420) == 420)
    self._reset_progress()
    assert (len(entries) == 2)
    self.failUnlessRaises(OSError, index.reset(new_commit).add, ['doesnt/exist/must/raise'])
    old_blob = new_commit.parents[0].tree.blobs[0]
    entries = index.reset(new_commit).add([old_blob], fprogress=self._fprogress_add)
    self._assert_entries(entries)
    self._assert_fprogress(entries)
    assert ((index.entries[(old_blob.path, 0)].hexsha == old_blob.hexsha) and (len(entries) == 1))
    null_hex_sha = Diff.NULL_HEX_SHA
    null_bin_sha = ('\x00' * 20)
    self.failUnlessRaises(ValueError, index.reset(new_commit).add, [BaseIndexEntry((0, null_bin_sha, 0, 'doesntmatter'))])
    new_file_relapath = 'my_new_file'
    new_file_path = self._make_file(new_file_relapath, 'hello world', rw_repo)
    entries = index.reset(new_commit).add([BaseIndexEntry((4516, null_bin_sha, 0, new_file_relapath))], fprogress=self._fprogress_add)
    self._assert_entries(entries)
    self._assert_fprogress(entries)
    assert ((len(entries) == 1) and (entries[0].hexsha != null_hex_sha))
    if (sys.platform != 'win32'):
        basename = 'my_real_symlink'
        target = '/etc/that'
        link_file = os.path.join(rw_repo.working_tree_dir, basename)
        os.symlink(target, link_file)
        entries = index.reset(new_commit).add([link_file], fprogress=self._fprogress_add)
        self._assert_entries(entries)
        self._assert_fprogress(entries)
        assert ((len(entries) == 1) and S_ISLNK(entries[0].mode))
        assert S_ISLNK(index.entries[index.entry_key('my_real_symlink', 0)].mode)
        assert (index.repo.odb.stream(entries[0].binsha).read() == target)
    fake_symlink_relapath = 'my_fake_symlink'
    link_target = '/etc/that'
    fake_symlink_path = self._make_file(fake_symlink_relapath, link_target, rw_repo)
    fake_entry = BaseIndexEntry((40960, null_bin_sha, 0, fake_symlink_relapath))
    entries = index.reset(new_commit).add([fake_entry], fprogress=self._fprogress_add)
    self._assert_entries(entries)
    self._assert_fprogress(entries)
    assert (entries[0].hexsha != null_hex_sha)
    assert ((len(entries) == 1) and S_ISLNK(entries[0].mode))
    full_index_entry = IndexEntry.from_base(BaseIndexEntry((40960, entries[0].binsha, 0, entries[0].path)))
    entry_key = index.entry_key(full_index_entry)
    index.reset(new_commit)
    assert (entry_key not in index.entries)
    index.entries[entry_key] = full_index_entry
    index.write()
    index.update()
    new_entry = index.entries[entry_key]
    assert S_ISLNK(new_entry.mode)
    tree = index.write_tree()
    assert (fake_symlink_relapath in tree)
    index.write()
    assert (not S_ISLNK(os.stat(fake_symlink_path)[ST_MODE]))
    os.remove(fake_symlink_path)
    index.checkout(fake_symlink_path)
    if (os.name == 'nt'):
        (open(fake_symlink_path, 'rb').read() == link_target)
    else:
        assert S_ISLNK(os.lstat(fake_symlink_path)[ST_MODE])

    def assert_mv_rval(rval):
        for (source, dest) in rval:
            assert ((not os.path.exists(source)) and os.path.exists(dest))
    self.failUnlessRaises(ValueError, index.move, ['just_one_path'])
    files = ['AUTHORS', 'LICENSE']
    self.failUnlessRaises(GitCommandError, index.move, files)
    assert_mv_rval(index.move(files, f=True))
    paths = ['LICENSE', 'VERSION', 'doc']
    rval = index.move(paths, dry_run=True)
    assert (len(rval) == 2)
    assert os.path.exists(paths[0])
    rval = index.move(paths)
    assert_mv_rval(rval)
    rval = index.move(['doc', 'test'])
    assert_mv_rval(rval)
    count = [0]

    def rewriter(entry):
        rval = str(count[0])
        count[0] += 1
        return rval

    def make_paths():
        yield 'CHANGES'
        yield 'ez_setup.py'
        yield index.entries[index.entry_key('README', 0)]
        yield index.entries[index.entry_key('.gitignore', 0)]
        for fid in range(3):
            fname = ('newfile%i' % fid)
            open(fname, 'wb').write('abcd')
            yield Blob(rw_repo, Blob.NULL_BIN_SHA, 33188, fname)
    paths = list(make_paths())
    self._assert_entries(index.add(paths, path_rewriter=rewriter))
    for filenum in range(len(paths)):
        assert (index.entry_key(str(filenum), 0) in index.entries)
    arela = 'aa'
    brela = 'bb'
    afile = self._make_file(arela, 'adata', rw_repo)
    bfile = self._make_file(brela, 'bdata', rw_repo)
    akey = index.entry_key(arela, 0)
    bkey = index.entry_key(brela, 0)
    keys = (akey, bkey)
    absfiles = (afile, bfile)
    files = (arela, brela)
    for fkey in keys:
        assert (not (fkey in index.entries))
    index.add(files, write=True)
    nc = index.commit('2 files committed', head=False)
    for fkey in keys:
        assert (fkey in index.entries)
    index.reset(paths=(arela, afile))
    assert (not (akey in index.entries))
    assert (bkey in index.entries)
    rw_repo.head.commit = nc
    for absfile in absfiles:
        os.remove(absfile)
    index.reset(working_tree=True, paths=files)
    for fkey in keys:
        assert (fkey in index.entries)
    for absfile in absfiles:
        assert os.path.isfile(absfile)
