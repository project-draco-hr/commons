{
  final Set<String> argsFailedToParse=Sets.newHashSet();
  final Set<String> argsConstraintsFailed=Sets.newHashSet();
  final Iterable<Pair<Field,CmdLine>> argDefs=Iterables.transform(argFields,PAIR_WITH_ANNOTATION);
  for (  Pair<Field,CmdLine> argDef : argDefs) {
    CHECK_ARG_DEF.execute(argDef);
  }
  Iterable<String> argShortNames=Iterables.transform(argDefs,Functions.compose(GET_ARG_NAME,Pair.<Field,CmdLine>second()));
  Set<String> argShortNamesNoCollisions=dropCollisions(argShortNames);
  Set<String> collisionsDropped=Sets.difference(ImmutableSet.copyOf(argShortNames),argShortNamesNoCollisions);
  if (!collisionsDropped.isEmpty()) {
    LOG.warning("Found argument name collisions, args must be referenced by canonical names: " + collisionsDropped);
  }
  Predicate<Pair<Field,CmdLine>> isBoolean=Predicates.compose(Predicates.<Class>equalTo(Boolean.class),Functions.compose(TypeUtil.GET_TYPE_PARAM_CLASS,Pair.<Field,CmdLine>first()));
  final Function<Pair<Field,CmdLine>,String> getFieldArgName=Functions.compose(GET_ARG_NAME,Pair.<Field,CmdLine>second());
  final Map<String,Pair<Field,CmdLine>> argsByName=ImmutableMap.<String,Pair<Field,CmdLine>>builder().putAll(Maps.uniqueIndex(Iterables.filter(argDefs,Predicates.compose(Predicates.in(argShortNamesNoCollisions),getFieldArgName)),getFieldArgName)).putAll(Maps.uniqueIndex(argDefs,GET_CANONICAL_ARG_NAME)).putAll(Maps.uniqueIndex(Iterables.filter(argDefs,isBoolean),Functions.compose(PREPEND_NEGATION,getFieldArgName))).putAll(Maps.uniqueIndex(Iterables.filter(argDefs,isBoolean),GET_CANONICAL_NEGATED_ARG_NAME)).build();
  Set<String> recognizedArgs=Sets.intersection(argsByName.keySet(),args.keySet());
  for (  String argName : recognizedArgs) {
    String argValue=args.get(argName);
    Field argField=argsByName.get(argName).getFirst();
    CmdLine annotation=argsByName.get(argName).getSecond();
    Object assignmentValue;
    try {
      assignmentValue=getParser(annotation,argField).parse(TypeUtil.getTypeParam(argField),argValue);
    }
 catch (    IllegalArgumentException e) {
      argsFailedToParse.add(argName + " - " + e.getMessage());
      continue;
    }
    if (TypeUtil.getTypeParamClass(argField) == Boolean.class) {
      Matcher negatedNameMatcher=NEGATED_BOOLEAN_PATTERN.matcher(argName);
      if (negatedNameMatcher.matches()) {
        String argShortName=negatedNameMatcher.group(negatedNameMatcher.groupCount());
        String argCanonicalName=negatedNameMatcher.groupCount() == 2 ? negatedNameMatcher.group(1) + argShortName : null;
        if (Iterables.any(argsByName.keySet(),Predicates.in(Arrays.asList(argShortName,argCanonicalName)))) {
          assignmentValue=(!(Boolean)assignmentValue);
        }
      }
    }
    setField(argField,assignmentValue);
  }
  infoLog("-------------------------------------------------------------------------");
  infoLog("Command line argument values");
  for (  Pair<Field,CmdLine> argDef : argDefs) {
    Field argField=argDef.getFirst();
    Arg arg=getArg(argField);
    infoLog(String.format("%s (%s.%s): %s",argDef.getSecond().name(),argField.getDeclaringClass().getName(),argField.getName(),arg.uncheckedGet()));
    try {
      checkConstraints(TypeUtil.getTypeParamClass(argField),arg.uncheckedGet(),argField.getAnnotations());
    }
 catch (    IllegalArgumentException e) {
      argsConstraintsFailed.add(argDef.getSecond().name() + " - " + e.getMessage());
    }
  }
  infoLog("-------------------------------------------------------------------------");
  ImmutableMultimap<String,String> warningMessages=ImmutableMultimap.<String,String>builder().putAll("Unrecognized arguments",Sets.difference(args.keySet(),argsByName.keySet())).putAll("Failed to parse",argsFailedToParse).putAll("Value did not meet constraints",argsConstraintsFailed).build();
  if (!warningMessages.isEmpty()) {
    StringBuilder sb=new StringBuilder();
    for (    Map.Entry<String,Collection<String>> warnings : warningMessages.asMap().entrySet()) {
      sb.append(warnings.getKey()).append(":\n\t").append(Joiner.on("\n\t").join(warnings.getValue())).append("\n");
    }
    throw new IllegalArgumentException(sb.toString());
  }
}
