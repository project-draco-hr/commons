{
  if (!Sets.intersection(args.keySet(),HELP_ARGS).isEmpty()) {
    printHelp(verifiers,argumentInfo);
    return false;
  }
  Optional<PositionalInfo> positionalInfo=argumentInfo.positionalInfo;
  checkArgument(positionalInfo.isPresent() || positionalArgs.isEmpty(),"Positional arguments have been supplied but there is no Arg annotated to received them.");
  if (positionalInfo.isPresent()) {
    PositionalInfo info=positionalInfo.get();
    checkArgDef(parserOracle,info.field,info.positional.parser());
  }
  Iterable<OptionInfo> optionInfos=argumentInfo.optionInfos;
  for (  OptionInfo optionInfo : optionInfos) {
    checkArgDef(parserOracle,optionInfo.field,optionInfo.cmdLine);
  }
  final Set<String> argsFailedToParse=Sets.newHashSet();
  final Set<String> argsConstraintsFailed=Sets.newHashSet();
  Iterable<String> argShortNames=Iterables.transform(optionInfos,Functions.compose(GET_ARG_NAME,GET_CMD_LINE));
  Set<String> argShortNamesNoCollisions=dropCollisions(argShortNames);
  Set<String> collisionsDropped=Sets.difference(ImmutableSet.copyOf(argShortNames),argShortNamesNoCollisions);
  if (!collisionsDropped.isEmpty()) {
    LOG.warning("Found argument name collisions, args must be referenced by canonical names: " + collisionsDropped);
  }
  Predicate<OptionInfo> isBoolean=Predicates.compose(Predicates.<Class>equalTo(Boolean.class),Functions.compose(TypeUtil.GET_TYPE_PARAM_CLASS,GET_FIELD));
  final Map<String,OptionInfo> argsByName=ImmutableMap.<String,OptionInfo>builder().putAll(Maps.uniqueIndex(Iterables.filter(optionInfos,Predicates.compose(Predicates.in(argShortNamesNoCollisions),GET_FIELD_ARG_NAME)),GET_FIELD_ARG_NAME)).putAll(Maps.uniqueIndex(optionInfos,GET_CANONICAL_ARG_NAME)).putAll(Maps.uniqueIndex(Iterables.filter(optionInfos,isBoolean),Functions.compose(PREPEND_NEGATION,GET_FIELD_ARG_NAME))).putAll(Maps.uniqueIndex(Iterables.filter(optionInfos,isBoolean),GET_CANONICAL_NEGATED_ARG_NAME)).build();
  Set<String> recognizedArgs=Sets.intersection(argsByName.keySet(),args.keySet());
  for (  String argName : recognizedArgs) {
    String argValue=args.get(argName);
    OptionInfo optionInfo=argsByName.get(argName);
    Field argField=optionInfo.field;
    Class<? extends Parser> parser=optionInfo.cmdLine.parser();
    Object assignmentValue;
    try {
      assignmentValue=getParser(parserOracle,parser,argField).parse(parserOracle,TypeUtil.getTypeParam(argField),argValue);
    }
 catch (    IllegalArgumentException e) {
      argsFailedToParse.add(argName + " - " + e.getMessage());
      continue;
    }
    if (TypeUtil.getTypeParamClass(argField) == Boolean.class) {
      Matcher negatedNameMatcher=NEGATED_BOOLEAN_PATTERN.matcher(argName);
      if (negatedNameMatcher.matches()) {
        String argShortName=negatedNameMatcher.group(negatedNameMatcher.groupCount());
        String argCanonicalName=negatedNameMatcher.groupCount() == 2 ? negatedNameMatcher.group(1) + argShortName : null;
        if (Iterables.any(argsByName.keySet(),Predicates.in(Arrays.asList(argShortName,argCanonicalName)))) {
          assignmentValue=(!(Boolean)assignmentValue);
        }
      }
    }
    setField(argField,assignmentValue);
  }
  if (positionalInfo.isPresent()) {
    PositionalInfo info=positionalInfo.get();
    final Field argField=info.field;
    Class<? extends Parser> custom=info.positional.parser();
    final Type elementType=TypeToken.extractTypeToken(TypeUtil.getTypeParam(argField));
    final Parser<?> parser=getParser(parserOracle,custom,TypeUtil.getRawType(elementType));
    List<?> assignmentValue=Lists.newArrayList(Iterables.transform(positionalArgs,new Function<String,Object>(){
      @Override public Object apply(      String argValue){
        return parser.parse(parserOracle,elementType,argValue);
      }
    }
));
    setField(argField,assignmentValue);
  }
  Set<String> commandLineArgumentInfos=Sets.newTreeSet();
  Iterable<Pair<String,Field>> argFields=Iterables.transform(optionInfos,new Function<OptionInfo,Pair<String,Field>>(){
    @Override public Pair<String,Field> apply(    OptionInfo optionInfo){
      return Pair.of(optionInfo.cmdLine.name(),optionInfo.field);
    }
  }
);
  if (positionalInfo.isPresent()) {
    PositionalInfo info=positionalInfo.get();
    argFields=Iterables.concat(argFields,ImmutableList.of(Pair.of("[positional args]",info.field)));
  }
  for (  Pair<String,Field> argInfo : argFields) {
    Field argField=argInfo.getSecond();
    Arg arg=getArg(argField);
    commandLineArgumentInfos.add(String.format("%s (%s.%s): %s",argInfo.getFirst(),argField.getDeclaringClass().getName(),argField.getName(),arg.uncheckedGet()));
    try {
      checkConstraints(verifiers,TypeUtil.getTypeParamClass(argField),arg.uncheckedGet(),argField.getAnnotations());
    }
 catch (    IllegalArgumentException e) {
      argsConstraintsFailed.add(argInfo.getFirst() + " - " + e.getMessage());
    }
  }
  ImmutableMultimap<String,String> warningMessages=ImmutableMultimap.<String,String>builder().putAll("Unrecognized arguments",Sets.difference(args.keySet(),argsByName.keySet())).putAll("Failed to parse",argsFailedToParse).putAll("Value did not meet constraints",argsConstraintsFailed).build();
  if (!warningMessages.isEmpty()) {
    printHelp(verifiers,argumentInfo);
    StringBuilder sb=new StringBuilder();
    for (    Map.Entry<String,Collection<String>> warnings : warningMessages.asMap().entrySet()) {
      sb.append(warnings.getKey()).append(":\n\t").append(Joiner.on("\n\t").join(warnings.getValue())).append("\n");
    }
    throw new IllegalArgumentException(sb.toString());
  }
  infoLog("-------------------------------------------------------------------------");
  infoLog("Command line argument values");
  for (  String commandLineArgumentInfo : commandLineArgumentInfos) {
    infoLog(commandLineArgumentInfo);
  }
  infoLog("-------------------------------------------------------------------------");
  return true;
}
