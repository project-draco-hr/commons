@git_working_dir
def add(self, items, force=True, fprogress=(lambda *args: None), path_rewriter=None, write=True):
    "Add files from the working tree, specific blobs or BaseIndexEntries\n\t\tto the index. \n\n\t\t:param items:\n\t\t\tMultiple types of items are supported, types can be mixed within one call.\n\t\t\tDifferent types imply a different handling. File paths may generally be\n\t\t\trelative or absolute.\n\n\t\t\t- path string\n\t\t\t\tstrings denote a relative or absolute path into the repository pointing to\n\t\t\t\tan existing file, i.e. CHANGES, lib/myfile.ext, '/home/gitrepo/lib/myfile.ext'.\n\n\t\t\t\tPaths provided like this must exist. When added, they will be written\n\t\t\t\tinto the object database.\n\n\t\t\t\tPathStrings may contain globs, such as 'lib/__init__*' or can be directories\n\t\t\t\tlike 'lib', the latter ones will add all the files within the dirctory and\n\t\t\t\tsubdirectories.\n\n\t\t\t\tThis equals a straight git-add.\n\n\t\t\t\tThey are added at stage 0\n\n\t\t\t- Blob or Submodule object\n\t\t\t\tBlobs are added as they are assuming a valid mode is set.\n\t\t\t\tThe file they refer to may or may not exist in the file system, but\n\t\t\t\tmust be a path relative to our repository.\n\n\t\t\t\tIf their sha is null ( 40*0 ), their path must exist in the file system\n\t\t\t\trelative to the git repository as an object will be created from \n\t\t\t\tthe data at the path.\n\t\t\t\tThe handling now very much equals the way string paths are processed, except that\n\t\t\t\tthe mode you have set will be kept. This allows you to create symlinks\n\t\t\t\tby settings the mode respectively and writing the target of the symlink\n\t\t\t\tdirectly into the file. This equals a default Linux-Symlink which\n\t\t\t\tis not dereferenced automatically, except that it can be created on\n\t\t\t\tfilesystems not supporting it as well.\n\n\t\t\t\tPlease note that globs or directories are not allowed in Blob objects.\n\n\t\t\t\tThey are added at stage 0\n\n\t\t\t- BaseIndexEntry or type\n\t\t\t\tHandling equals the one of Blob objects, but the stage may be\n\t\t\t\texplicitly set. Please note that Index Entries require binary sha's.\n\n\t\t:param force:\n\t\t\t**CURRENTLY INEFFECTIVE**\n\t\t\tIf True, otherwise ignored or excluded files will be\n\t\t\tadded anyway.\n\t\t\tAs opposed to the git-add command, we enable this flag by default\n\t\t\tas the API user usually wants the item to be added even though\n\t\t\tthey might be excluded.\n\n\t\t:param fprogress:\n\t\t\tFunction with signature f(path, done=False, item=item) called for each\n\t\t\tpath to be added, one time once it is about to be added where done==False\n\t\t\tand once after it was added where done=True.\n\t\t\titem is set to the actual item we handle, either a Path or a BaseIndexEntry\n\t\t\tPlease note that the processed path is not guaranteed to be present\n\t\t\tin the index already as the index is currently being processed.\n\n\t\t:param path_rewriter:\n\t\t\tFunction with signature (string) func(BaseIndexEntry) function returning a path\n\t\t\tfor each passed entry which is the path to be actually recorded for the\n\t\t\tobject created from entry.path. This allows you to write an index which\n\t\t\tis not identical to the layout of the actual files on your hard-disk.\n\t\t\tIf not None and ``items`` contain plain paths, these paths will be\n\t\t\tconverted to Entries beforehand and passed to the path_rewriter.\n\t\t\tPlease note that entry.path is relative to the git repository.\n\n\t\t:param write:\n\t\t\t\tIf True, the index will be written once it was altered. Otherwise\n\t\t\t\tthe changes only exist in memory and are not available to git commands.\n\t\t\n\t\t:return:\n\t\t\tList(BaseIndexEntries) representing the entries just actually added.\n\n\t\t:raise OSError:\n\t\t\tif a supplied Path did not exist. Please note that BaseIndexEntry\n\t\t\tObjects that do not have a null sha will be added even if their paths\n\t\t\tdo not exist.\n\t\t"
    entries_added = list()
    (paths, entries) = self._preprocess_add_items(items)
    if (paths and path_rewriter):
        for path in paths:
            abspath = os.path.abspath(path)
            gitrelative_path = abspath[(len(self.repo.working_tree_dir) + 1):]
            blob = Blob(self.repo, Blob.NULL_BIN_SHA, stat_mode_to_index_mode(os.stat(abspath).st_mode), to_native_path_linux(gitrelative_path))
            entries.append(BaseIndexEntry.from_blob(blob))
        del paths[:]

    def store_path(filepath):
        'Store file at filepath in the database and return the base index entry'
        st = os.lstat(filepath)
        stream = None
        if S_ISLNK(st.st_mode):
            stream = StringIO(os.readlink(filepath))
        else:
            stream = open(filepath, 'rb')
        fprogress(filepath, False, filepath)
        istream = self.repo.odb.store(IStream(Blob.type, st.st_size, stream))
        fprogress(filepath, True, filepath)
        return BaseIndexEntry((stat_mode_to_index_mode(st.st_mode), istream.binsha, 0, to_native_path_linux(filepath)))
    if paths:
        assert (len(entries_added) == 0)
        added_files = list()
        for filepath in self._iter_expand_paths(paths):
            entries_added.append(store_path(filepath))
    if entries:
        null_mode_entries = [e for e in entries if (e.mode == 0)]
        if null_mode_entries:
            raise ValueError('At least one Entry has a null-mode - please use index.remove to remove files for clarity')
        null_entries_indices = [i for (i, e) in enumerate(entries) if (e.binsha == Object.NULL_BIN_SHA)]
        if null_entries_indices:
            for ei in null_entries_indices:
                null_entry = entries[ei]
                new_entry = store_path(null_entry.path)
                entries[ei] = BaseIndexEntry((null_entry.mode, new_entry.binsha, null_entry.stage, null_entry.path))
        if path_rewriter:
            for (i, e) in enumerate(entries):
                entries[i] = BaseIndexEntry((e.mode, e.binsha, e.stage, path_rewriter(e)))
        for (i, entry) in enumerate(entries):
            progress_sent = (i in null_entries_indices)
            if (not progress_sent):
                fprogress(entry.path, False, entry)
                fprogress(entry.path, True, entry)
        entries_added.extend(entries)
    for entry in entries_added:
        self.entries[(entry.path, 0)] = IndexEntry.from_base(entry)
    if write:
        self.write()
    return entries_added
