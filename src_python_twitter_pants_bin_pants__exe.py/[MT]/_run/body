def _run():
    version = get_version()
    if ((len(sys.argv) == 2) and (sys.argv[1] == _VERSION_OPTION)):
        _do_exit(version)
    root_dir = get_buildroot()
    if (not os.path.exists(root_dir)):
        _exit_and_fail(('PANTS_BUILD_ROOT does not point to a valid path: %s' % root_dir))
    if ((len(sys.argv) < 2) or ((len(sys.argv) == 2) and (sys.argv[1] in _HELP_ALIASES))):
        _help(version, root_dir)
    (command_class, command_args) = _parse_command(root_dir, sys.argv[1:])
    parser = optparse.OptionParser(version=version)
    RcFile.install_disable_rc_option(parser)
    parser.add_option(_LOG_EXIT_OPTION, action='store_true', default=False, dest='log_exit', help='Log an exit message on success or failure.')
    command = command_class(root_dir, parser, command_args)
    if command.serialized():

        def onwait(pid):
            print(('Waiting on pants process %s to complete' % _process_info(pid)), file=sys.stderr)
            return True
        runfile = os.path.join(root_dir, '.pants.run')
        lock = Lock.acquire(runfile, onwait=onwait)
    else:
        lock = Lock.unlocked()
    try:
        try:
            result = command.run(lock)
            _do_exit(result)
        except KeyboardInterrupt:
            command.cleanup()
            raise
    finally:
        lock.release()
