@classmethod
def sort_targets(cls, internal_targets):
    'Returns a list of targets that internal_targets depend on sorted from most dependent to\n    least.\n    '
    roots = OrderedSet()
    inverted_deps = collections.defaultdict(OrderedSet)
    visited = set()
    path = OrderedSet()

    def invert(target):
        if (target in path):
            path_list = list(path)
            cycle_head = path_list.index(target)
            cycle = (path_list[cycle_head:] + [target])
            raise cls.CycleException(cycle)
        path.add(target)
        if (target not in visited):
            visited.add(target)
            if getattr(target, 'internal_dependencies', None):
                for internal_dependency in target.internal_dependencies:
                    if hasattr(internal_dependency, 'internal_dependencies'):
                        inverted_deps[internal_dependency].add(target)
                        invert(internal_dependency)
            else:
                roots.add(target)
        path.remove(target)
    for internal_target in internal_targets:
        invert(internal_target)
    ordered = []
    visited.clear()

    def topological_sort(target):
        if (target not in visited):
            visited.add(target)
            if (target in inverted_deps):
                for dep in inverted_deps[target]:
                    topological_sort(dep)
            ordered.append(target)
    for root in roots:
        topological_sort(root)
    return ordered
