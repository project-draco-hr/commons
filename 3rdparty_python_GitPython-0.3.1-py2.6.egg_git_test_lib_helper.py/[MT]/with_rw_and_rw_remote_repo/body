def with_rw_and_rw_remote_repo(working_tree_ref):
    '\n\tSame as with_rw_repo, but also provides a writable remote repository from which the\n\trw_repo has been forked as well as a handle for a git-daemon that may be started to \n\trun the remote_repo.\n\tThe remote repository was cloned as bare repository from the rorepo, wheras \n\tthe rw repo has a working tree and was cloned from the remote repository.\n\t\n\tremote_repo has two remotes: origin and daemon_origin. One uses a local url, \n\tthe other uses a server url. The daemon setup must be done on system level \n\tand should be an inetd service that serves tempdir.gettempdir() and all \n\tdirectories in it.\n\t\n\tThe following scetch demonstrates this::\n\t rorepo ---<bare clone>---> rw_remote_repo ---<clone>---> rw_repo\n\t\n\tThe test case needs to support the following signature::\n\t\tdef case(self, rw_repo, rw_remote_repo)\n\t\t\n\tThis setup allows you to test push and pull scenarios and hooks nicely.\n\t\n\tSee working dir info in with_rw_repo\n\t'
    assert isinstance(working_tree_ref, basestring), 'Decorator requires ref name for working tree checkout'

    def argument_passer(func):

        def remote_repo_creator(self):
            remote_repo_dir = _mktemp(('remote_repo_%s' % func.__name__))
            repo_dir = _mktemp('remote_clone_non_bare_repo')
            rw_remote_repo = self.rorepo.clone(remote_repo_dir, shared=True, bare=True)
            rw_repo = rw_remote_repo.clone(repo_dir, shared=True, bare=False, n=True)
            rw_repo.head.commit = working_tree_ref
            rw_repo.head.reference.checkout()
            rw_remote_repo.daemon_export = True
            crw = rw_remote_repo.config_writer()
            section = 'daemon'
            try:
                crw.add_section(section)
            except Exception:
                pass
            crw.set(section, 'receivepack', True)
            del crw
            d_remote = Remote.create(rw_repo, 'daemon_origin', remote_repo_dir)
            d_remote.fetch()
            remote_repo_url = ('git://localhost%s' % remote_repo_dir)
            d_remote.config_writer.set('url', remote_repo_url)
            try:
                rw_repo.git.ls_remote(d_remote)
            except GitCommandError as e:
                print str(e)
                if (os.name == 'nt'):
                    raise AssertionError(('git-daemon needs to run this test, but windows does not have one. Otherwise, run: git-daemon "%s"' % tempfile.gettempdir()))
                else:
                    raise AssertionError(('Please start a git-daemon to run this test, execute: git-daemon "%s"' % tempfile.gettempdir()))
            prev_cwd = os.getcwd()
            os.chdir(rw_repo.working_dir)
            try:
                return func(self, rw_repo, rw_remote_repo)
            finally:
                os.chdir(prev_cwd)
                rw_repo.git.clear_cache()
                rw_remote_repo.git.clear_cache()
                shutil.rmtree(repo_dir, onerror=_rmtree_onerror)
                shutil.rmtree(remote_repo_dir, onerror=_rmtree_onerror)
        remote_repo_creator.__name__ = func.__name__
        return remote_repo_creator
    return argument_passer
