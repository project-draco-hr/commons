def _compute_targets_by_file(self):
    'Returns a map from abs path of source, class or jar file to an OrderedSet of targets.\n\n    The value is usually a singleton, because a source or class file belongs to a single target.\n    However a single jar may be provided (transitively or intransitively) by multiple JarLibrary\n    targets. But if there is a JarLibrary target that depends on a jar directly, then that\n    "canonical" target will be the first one in the list of targets.\n    '
    targets_by_file = defaultdict(OrderedSet)
    jarlibs_by_id = defaultdict(set)
    buildroot = get_buildroot()
    for target in self._context.targets():
        if isinstance(target, JvmTarget):
            for src in target.sources_relative_to_buildroot():
                targets_by_file[os.path.join(buildroot, src)].add(target)
        elif isinstance(target, JarLibrary):
            for jardep in target.dependencies:
                if isinstance(jardep, JarDependency):
                    jarlibs_by_id[(jardep.org, jardep.name)].add(target)
    classes_by_target = self._context.products.get_data('classes_by_target')
    for (tgt, target_products) in classes_by_target.items():
        for (_, classes) in target_products.abs_paths():
            for cls in classes:
                targets_by_file[cls].add(tgt)
    with Task.symlink_map_lock:
        all_symlinks_map = self._context.products.get_data('symlink_map').copy()

    def register_transitive_jars_for_ref(ivyinfo, ref):
        deps_by_ref_memo = {}

        def get_transitive_jars_by_ref(ref1, visited=None):
            if (ref1 in deps_by_ref_memo):
                return deps_by_ref_memo[ref1]
            else:
                visited = (visited or set())
                if (ref1 in visited):
                    return set()
                visited.add(ref1)
                jars = set()
                jars.update(ivyinfo.modules_by_ref[ref1].artifacts)
                for dep in ivyinfo.deps_by_caller.get(ref1, []):
                    jars.update(get_transitive_jars_by_ref(dep, visited))
                deps_by_ref_memo[ref1] = jars
                return jars
        target_key = (ref.org, ref.name)
        if (target_key in jarlibs_by_id):
            jarlib_targets = jarlibs_by_id[target_key]
            for jar in get_transitive_jars_by_ref(ref):
                symlinks = all_symlinks_map.get(os.path.realpath(jar.path), [])
                for symlink in symlinks:
                    for jarlib_target in jarlib_targets:
                        targets_by_file[symlink].add(jarlib_target)
    ivy_products = self._context.products.get_data('ivy_jar_products')
    if ivy_products:
        for ivyinfos in ivy_products.values():
            for ivyinfo in ivyinfos:
                for ref in ivyinfo.modules_by_ref:
                    register_transitive_jars_for_ref(ivyinfo, ref)
    return targets_by_file
