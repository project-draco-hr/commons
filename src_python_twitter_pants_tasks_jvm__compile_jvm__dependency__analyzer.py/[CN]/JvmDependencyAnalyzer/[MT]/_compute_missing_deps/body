def _compute_missing_deps(self, srcs, actual_deps):
    "Computes deps that are used by the compiler but not specified in a BUILD file.\n\n    These deps are bugs waiting to happen: the code may happen to compile because the dep was\n    brought in some other way (e.g., by some other root target), but that is obviously fragile.\n\n    Note that in practice we're OK with reliance on indirect deps that are only brought in\n    transitively. E.g., in Scala type inference can bring in such a dep subtly. Fortunately these\n    cases aren't as fragile as a completely missing dependency. It's still a good idea to have\n    explicit direct deps where relevant, so we optionally warn about indirect deps, to make them\n    easy to find and reason about.\n\n    - actual_deps: a map src -> list of actual deps (source, class or jar file) as noted by the\n      compiler.\n\n    Returns a triple (missing_file_deps, missing_tgt_deps, missing_direct_tgt_deps) where:\n\n    - missing_file_deps: a list of pairs (src_tgt, dep_file) where src_tgt requires dep_file, and\n      we're unable to map to a target (because its target isn't in the total set of targets in play,\n      and we don't want to parse every BUILD file in the workspace just to find it).\n\n    - missing_tgt_deps: a list of pairs (src_tgt, dep_tgt) where src_tgt is missing a necessary\n                        transitive dependency on dep_tgt.\n\n    - missing_direct_tgt_deps: a list of pairs (src_tgt, dep_tgt) where src_tgt is missing a direct\n                               dependency on dep_tgt but has a transitive dep on it.\n\n    All paths in the input and output are absolute.\n    "

    def must_be_explicit_dep(dep):
        return (not dep.startswith(self._context.java_home))
    targets_by_file = self._compute_targets_by_file()
    transitive_deps_by_target = self._compute_transitive_deps_by_target()
    missing_file_deps = OrderedSet()
    missing_tgt_deps_map = defaultdict(list)
    missing_direct_tgt_deps_map = defaultdict(list)
    buildroot = get_buildroot()
    abs_srcs = [os.path.join(buildroot, src) for src in srcs]
    for src in abs_srcs:
        src_tgt = next(iter(targets_by_file.get(src)))
        if (src_tgt is not None):
            for actual_dep in filter(must_be_explicit_dep, actual_deps.get(src, [])):
                actual_dep_tgts = targets_by_file.get(actual_dep)
                if (actual_dep_tgts is None):
                    missing_file_deps.add((src_tgt, actual_dep))
                elif (src_tgt not in actual_dep_tgts):
                    canonical_actual_dep_tgt = next(iter(actual_dep_tgts))
                    if actual_dep_tgts.isdisjoint(transitive_deps_by_target.get(src_tgt, [])):
                        missing_tgt_deps_map[(src_tgt, canonical_actual_dep_tgt)].append((src, actual_dep))
                    elif (canonical_actual_dep_tgt not in src_tgt.dependencies):
                        missing_direct_tgt_deps_map[(src_tgt, canonical_actual_dep_tgt)].append((src, actual_dep))
        else:
            raise TaskError(('Requested dep info for unknown source file: %s' % src))
    return (list(missing_file_deps), missing_tgt_deps_map.items(), missing_direct_tgt_deps_map.items())
