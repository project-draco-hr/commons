def end_workunit(self, workunit):
    'Implementation of Reporter callback.'
    duration = workunit.duration()
    timing = ('%.3f' % duration)
    unaccounted_time_secs = workunit.unaccounted_time()
    unaccounted_time = (('%.3f' % unaccounted_time_secs) if ((unaccounted_time_secs >= 1) and (unaccounted_time_secs > (0.05 * duration))) else None)
    args = {'workunit': workunit.to_dict(), 'status': workunit.choose(*HtmlReporter._outcome_css_classes), 'timing': timing, 'unaccounted_time': unaccounted_time, 'aborted': (workunit.outcome() == WorkUnit.ABORTED), }
    s = ''
    if workunit.has_label(WorkUnit.TOOL):
        s += self._renderer.render_name('tool_invocation_end', args)
    s += self._renderer.render_name('workunit_end', args)
    self._emit(s)

    def render_timings(timings):
        timings_dict = timings.get_all()
        for item in timings_dict:
            item['timing_string'] = ('%.3f' % item['timing'])
        args = {'timings': timings_dict, }
        return self._renderer.render_name('aggregated_timings', args)
    self._overwrite('cumulative_timings', render_timings(self.run_tracker.cumulative_timings))
    self._overwrite('self_timings', render_timings(self.run_tracker.self_timings))

    def render_cache_stats(artifact_cache_stats):

        def fix_detail_id(e, _id):
            return (e if isinstance(e, basestring) else (e + (_id,)))
        msg_elements = []
        for (cache_name, stat) in artifact_cache_stats.stats_per_cache.items():
            msg_elements.extend([(cache_name + ' artifact cache: '), fix_detail_id(items_to_report_element(stat.hit_targets, 'hit'), 'cache-hit-details'), ', ', fix_detail_id(items_to_report_element(stat.miss_targets, 'miss'), 'cache-miss-details'), '.'])
        if (not msg_elements):
            msg_elements = ['No artifact cache use.']
        return self._render_message(*msg_elements)
    self._overwrite('artifact_cache_stats', render_cache_stats(self.run_tracker.artifact_cache_stats))
