def console_output(self, targets):
    if self._provides:

        def extract_artifact_id(target):
            (provided_jar, _, _) = target.get_artifact_info()
            return ('%s%s%s' % (provided_jar.org, '#', provided_jar.name))
        extractors = dict(address=(lambda target: str(target.address)), artifact_id=extract_artifact_id, repo_name=(lambda target: target.provides.repo.name), repo_url=(lambda target: target.provides.repo.url), repo_db=(lambda target: target.provides.repo.push_db))

        def print_provides(column_extractors, address):
            target = Target.get(address)
            if target.is_exported:
                return ' '.join((extractor(target) for extractor in column_extractors))
        try:
            column_extractors = [extractors[col] for col in self._provides_columns.split(',')]
        except KeyError:
            raise TaskError(('Invalid columns specified %s. Valid ones include address, artifact_id, repo_name, repo_url and repo_db.' % self._provides_columns))
        print_fn = (lambda address: print_provides(column_extractors, address))
    elif self._documented:

        def print_documented(address):
            target = Target.get(address)
            if target.description:
                return ('%s\n  %s' % (address, '\n  '.join(target.description.strip().split('\n'))))
        print_fn = print_documented
    else:
        print_fn = (lambda address: str(address))
    visited = set()
    for address in self._addresses():
        result = print_fn(address)
        if (result and (result not in visited)):
            visited.add(result)
            yield result
