def __init__(self, org, name, rev=None, force=False, ext=None, url=None, apidocs=None, type_=None, classifier=None, mutable=None, exclusives=None):
    '\n    :param string org: The Maven ``groupId`` of this dependency.\n    :param string name: The Maven ``artifactId`` of this dependency.\n    :param string rev: The Maven ``version`` of this dependency.\n      If unspecified the latest available version is used.\n    :param boolean force: Force this specific artifact revision even if other transitive\n      dependencies specify a different revision. This requires specifying the ``rev`` parameter.\n    :param string ext: Extension of the artifact if different from the artifact type.\n      This is sometimes needed for artifacts packaged with Maven bundle type but stored as jars.\n    :param string url: URL of this artifact, if different from the Maven repo standard location\n      (specifying this parameter is unusual).\n    :param string apidocs: URL of existing javadocs, which if specified, pants-generated javadocs\n      will properly hyperlink {\\ @link}s.\n    :param string type_: Artifact packaging type.\n    :param string classifier: Classifier specifying the artifact variant to use.\n      Use ``with_artifact`` to include multiple artifacts with different classifiers.\n    :param boolean mutable: Inhibit caching of this mutable artifact. A common use is for\n      Maven -SNAPSHOT style artifacts in an active development/integration cycle.\n    '
    self.org = org
    self.name = name
    self.rev = rev
    self.force = force
    self.excludes = []
    self.transitive = True
    self.apidocs = apidocs
    self.mutable = mutable
    self._classifier = classifier
    self.artifacts = []
    if (ext or url or type_ or classifier):
        self.with_artifact(name=name, type_=type_, ext=ext, url=url, classifier=classifier)
    self.id = ('%s-%s-%s' % (self.org, self.name, self.rev))
    self._configurations = ['default']
    self.declared_exclusives = defaultdict(set)
    if (exclusives is not None):
        for k in exclusives:
            self.declared_exclusives[k] |= exclusives[k]
    self.withSources = self.with_sources
    self.withDocs = self.with_sources
    self.declared_exclusives = defaultdict(set)
    if (exclusives is not None):
        for k in exclusives:
            self.declared_exclusives[k] |= exclusives[k]
