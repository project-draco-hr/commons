def configure_jvm(self, scala_compiler_profile, extra_source_paths, extra_test_paths):
    "\n      Configures this project's source sets returning the full set of targets the project is\n      comprised of.  The full set can be larger than the initial set of targets when any of the\n      initial targets only has partial ownership of its source set's directories.\n    "
    analyzed = OrderedSet()
    targeted = set()

    def source_target(target):
        return (has_sources(target) and ((not target.is_codegen) and (not (self.skip_java and is_java(target))) and (not (self.skip_scala and is_scala(target)))))

    def configure_source_sets(relative_base, sources, is_test):
        absolute_base = os.path.join(self.root_dir, relative_base)
        paths = set([os.path.dirname(source) for source in sources])
        for path in paths:
            absolute_path = os.path.join(absolute_base, path)
            if (absolute_path not in targeted):
                targeted.add(absolute_path)
                self.sources.append(SourceSet(self.root_dir, relative_base, path, is_test))

    def find_source_basedirs(target):
        dirs = set()
        if source_target(target):
            absolute_base = os.path.join(self.root_dir, target.target_base)
            dirs.update([os.path.join(absolute_base, os.path.dirname(source)) for source in target.sources])
        return dirs

    def configure_target(target):
        if (target not in analyzed):
            analyzed.add(target)
            self.has_scala = ((not self.skip_scala) and (self.has_scala or is_scala(target)))
            if (isinstance(target, JavaLibrary) or isinstance(target, ScalaLibrary)):
                resources = set()
                if target.resources:
                    resources.update(target.resources)
                if resources:
                    self.resource_extensions.update(Project.extract_resource_extensions(resources))
                    configure_source_sets(ExportableJvmLibrary.RESOURCES_BASE_DIR, resources, is_test=False)
            if target.sources:
                test = is_test(target)
                self.has_tests = (self.has_tests or test)
                configure_source_sets(target.target_base, target.sources, is_test=test)
            target_dirset = find_source_basedirs(target)
            candidates = Target.get_all_addresses(target.address.buildfile)
            for ancestor in target.address.buildfile.ancestors():
                candidates.update(Target.get_all_addresses(ancestor))
            for sibling in target.address.buildfile.siblings():
                candidates.update(Target.get_all_addresses(sibling))
            for descendant in target.address.buildfile.descendants():
                candidates.update(Target.get_all_addresses(descendant))

            def is_sibling(target):
                return (source_target(target) and target_dirset.intersection(find_source_basedirs(target)))
            return filter(is_sibling, [Target.get(a) for a in candidates if (a != target.address)])
    for target in self.targets:
        target.walk(configure_target, predicate=source_target)
    self.configure_profiles(scala_compiler_profile)
    unexcludable_paths = set()
    for source_set in self.sources:
        parent = os.path.join(self.root_dir, source_set.source_base, source_set.path)
        while True:
            unexcludable_paths.add(parent)
            (parent, dir) = os.path.split(parent)
            if (parent == self.root_dir):
                break
    for source_set in self.sources:
        paths = set()
        source_base = os.path.join(self.root_dir, source_set.source_base)
        for (root, dirs, _) in os.walk(os.path.join(source_base, source_set.path)):
            if dirs:
                paths.update([os.path.join(root, dir) for dir in dirs])
        unused_children = (paths - targeted)
        if unused_children:
            for child in unused_children:
                if (child not in unexcludable_paths):
                    source_set.excludes.append(os.path.relpath(child, source_base))
    targets = OrderedSet()
    for target in self.targets:
        target.walk((lambda target: targets.add(target)), source_target)
    targets.update((analyzed - targets))
    self.sources.extend((SourceSet(get_buildroot(), p, None, False) for p in extra_source_paths))
    self.sources.extend((SourceSet(get_buildroot(), p, None, True) for p in extra_test_paths))
    return targets
