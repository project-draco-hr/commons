@staticmethod
def execute(phase, tasks_by_goal, context, executed, timer=None):
    'Executes the named phase against the current context tracking goal executions in executed.'

    def _acquire_lock_if_needed(goal):
        "If the goal about to be executed requires the lock, then acquire it. If not,\n         then make sure it's released."
        if goal.serialize:
            context.acquire_lock()
        else:
            context.release_lock()

    def execute_task(name, task, targets):
        'Execute and time a single goal that has had all of its dependencies satisfied.'
        start = (timer.now() if timer else None)
        try:
            task.execute(targets)
        finally:
            elapsed = ((timer.now() - start) if timer else None)
            if (phase not in executed):
                executed[phase] = OrderedDict()
            if elapsed:
                phase_timings = executed[phase]
                if (name not in phase_timings):
                    phase_timings[name] = []
                phase_timings[name].append(elapsed)
    if (phase not in executed):
        goals = phase.goals()
        if (not goals):
            raise TaskError(('No goals installed for phase %s' % phase))
        for goal in goals:
            for dependency in goal.dependencies:
                Group.execute(dependency, tasks_by_goal, context, executed, timer=timer)
        runqueue = []
        goals_by_group = {}
        for goal in goals:
            if goal.group:
                group_name = goal.group.name
                if (group_name not in goals_by_group):
                    group_goals = [goal]
                    runqueue.append((group_name, group_goals))
                    goals_by_group[group_name] = group_goals
                else:
                    goals_by_group[group_name].append(goal)
            else:
                runqueue.append((None, [goal]))
        try:
            for (group_name, goals) in runqueue:
                if (not group_name):
                    goal = goals[0]
                    _acquire_lock_if_needed(goal)
                    context.log.info(('[%s:%s]' % (phase, goal.name)))
                    execute_task(goal.name, tasks_by_goal[goal], context.targets())
                else:
                    for chunk in Group.create_chunks(context, goals):
                        for goal in goals:
                            _acquire_lock_if_needed(goal)
                            goal_chunk = filter(goal.group.predicate, chunk)
                            if (len(goal_chunk) > 0):
                                context.log.info(('[%s:%s:%s]' % (phase, group_name, goal.name)))
                                execute_task(goal.name, tasks_by_goal[goal], goal_chunk)
        finally:
            context.release_lock()
