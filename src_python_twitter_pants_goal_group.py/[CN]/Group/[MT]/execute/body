@staticmethod
def execute(phase, tasks_by_goal, context, executed):
    'Executes the named phase against the current context tracking goal executions in executed.'

    def execute_task(name, task, targets):
        'Execute and time a single goal that has had all of its dependencies satisfied.'
        try:
            if getattr(context.options, 'explain', None):
                context.log.debug(('Skipping execution of %s in explain mode' % name))
            else:
                task.execute(targets)
        finally:
            if (phase not in executed):
                executed[phase] = OrderedDict()
    tasks_by_goalname = dict(((goal.name, task.__class__.__name__) for (goal, task) in tasks_by_goal.items()))

    def expand_goal(goal):
        if (len(goal) == 2):
            (group_name, goal_name) = goal
            task_name = tasks_by_goalname[goal_name]
            return ('%s:%s->%s' % (group_name, goal_name, task_name))
        else:
            task_name = tasks_by_goalname[goal]
            return ('%s->%s' % (goal, task_name))
    if (phase not in executed):
        locked_by_me = False
        if (context.is_unlocked() and phase.serialize()):
            context.acquire_lock()
            locked_by_me = True
        goals = phase.goals()
        if (not goals):
            raise TaskError(('No goals installed for phase %s' % phase))
        for goal in goals:
            for dependency in goal.dependencies:
                Group.execute(dependency, tasks_by_goal, context, executed)
        runqueue = []
        goals_by_group = {}
        for goal in goals:
            if goal.group:
                group_name = goal.group.name
                if (group_name not in goals_by_group):
                    group_goals = [goal]
                    runqueue.append((group_name, group_goals))
                    goals_by_group[group_name] = group_goals
                else:
                    goals_by_group[group_name].append(goal)
            else:
                runqueue.append((None, [goal]))
        with context.new_workunit(name=phase.name, labels=[WorkUnit.PHASE]):
            execution_phases = defaultdict(OrderedSet)
            for (group_name, goals) in runqueue:
                if (not group_name):
                    goal = goals[0]
                    execution_phases[phase].add(goal.name)
                    with context.new_workunit(name=goal.name, labels=[WorkUnit.GOAL]):
                        execute_task(goal.name, tasks_by_goal[goal], context.targets())
                else:
                    with context.new_workunit(name=group_name, labels=[WorkUnit.GROUP]):
                        for chunk in Group._create_chunks(context, goals):
                            for goal in goals:
                                goal_chunk = filter(goal.group.predicate, chunk)
                                if (len(goal_chunk) > 0):
                                    execution_phases[phase].add((group_name, goal.name))
                                    with context.new_workunit(name=goal.name, labels=[WorkUnit.GOAL]):
                                        execute_task(goal.name, tasks_by_goal[goal], goal_chunk)
        if getattr(context.options, 'explain', None):
            for (phase, goals) in execution_phases.items():
                goal_to_task = ', '.join((expand_goal(goal) for goal in goals))
                print ('%s [%s]' % (phase, goal_to_task))
        if locked_by_me:
            context.release_lock()
