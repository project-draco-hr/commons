@staticmethod
def execute(phase, tasks_by_goal, context, executed, timer=None):
    'Executes the named phase against the current context tracking goal executions in executed.'

    def execute_task(name, task, targets):
        'Execute and time a single goal that has had all of its dependencies satisfied.'
        start = (timer.now() if timer else None)
        try:
            task.execute(targets)
        finally:
            elapsed = ((timer.now() - start) if timer else None)
            if (phase not in executed):
                executed[phase] = OrderedDict()
            if elapsed:
                phase_timings = executed[phase]
                if (name not in phase_timings):
                    phase_timings[name] = []
                phase_timings[name].append(elapsed)
    if (phase not in executed):
        locked_by_me = False
        if (context.is_unlocked() and phase.serialize()):
            context.acquire_lock()
            locked_by_me = True
        goals = phase.goals()
        if (not goals):
            raise TaskError(('No goals installed for phase %s' % phase))
        for goal in goals:
            for dependency in goal.dependencies:
                Group.execute(dependency, tasks_by_goal, context, executed, timer=timer)
        runqueue = []
        goals_by_group = {}
        for goal in goals:
            if goal.group:
                group_name = goal.group.name
                if (group_name not in goals_by_group):
                    group_goals = [goal]
                    runqueue.append((group_name, group_goals))
                    goals_by_group[group_name] = group_goals
                else:
                    goals_by_group[group_name].append(goal)
            else:
                runqueue.append((None, [goal]))
        for (group_name, goals) in runqueue:
            if (not group_name):
                goal = goals[0]
                context.log.info(('[%s:%s]' % (phase, goal.name)))
                execute_task(goal.name, tasks_by_goal[goal], context.targets())
            else:
                for chunk in Group.create_chunks(context, goals):
                    for goal in goals:
                        goal_chunk = filter(goal.group.predicate, chunk)
                        if (len(goal_chunk) > 0):
                            context.log.info(('[%s:%s:%s]' % (phase, group_name, goal.name)))
                            execute_task(goal.name, tasks_by_goal[goal], goal_chunk)
        if locked_by_me:
            context.release_lock()
