@staticmethod
def execute(phase, tasks_by_goal, context, executed):
    'Executes the named phase against the current context tracking goal executions in executed.'

    def execute_task(name, task, targets):
        'Execute and time a single goal that has had all of its dependencies satisfied.'
        start = (context.timer.now() if context.timer else None)
        try:
            if getattr(context.options, 'explain', None):
                context.log.debug(('Skipping execution of %s in explain mode' % name))
            else:
                task.execute(targets)
        finally:
            elapsed = ((context.timer.now() - start) if context.timer else None)
            if (phase not in executed):
                executed[phase] = OrderedDict()
            if elapsed:
                phase_timings = executed[phase]
                if (name not in phase_timings):
                    phase_timings[name] = []
                phase_timings[name].append(elapsed)
    tasks_by_goalname = dict(((goal.name, task.__class__.__name__) for (goal, task) in tasks_by_goal.items()))

    def expand_goal(goal):
        if (len(goal) == 2):
            (group_name, goal_name) = goal
            task_name = tasks_by_goalname[goal_name]
            return ('%s:%s->%s' % (group_name, goal_name, task_name))
        else:
            task_name = tasks_by_goalname[goal]
            return ('%s->%s' % (goal, task_name))
    if (phase not in executed):
        locked_by_me = False
        if (context.is_unlocked() and phase.serialize()):
            context.acquire_lock()
            locked_by_me = True
        goals = phase.goals()
        if (not goals):
            raise TaskError(('No goals installed for phase %s' % phase))
        for goal in goals:
            for dependency in goal.dependencies:
                Group.execute(dependency, tasks_by_goal, context, executed)
        runqueue = []
        goals_by_group = {}
        for goal in goals:
            if goal.group:
                group_name = goal.group.name
                if (group_name not in goals_by_group):
                    group_goals = [goal]
                    runqueue.append((group_name, group_goals))
                    goals_by_group[group_name] = group_goals
                else:
                    goals_by_group[group_name].append(goal)
            else:
                runqueue.append((None, [goal]))
        execution_phases = defaultdict(OrderedSet)
        for (group_name, goals) in runqueue:
            if (not group_name):
                goal = goals[0]
                context.log.info(('[%s:%s]' % (phase, goal.name)))
                execution_phases[phase].add(goal.name)
                execute_task(goal.name, tasks_by_goal[goal], context.targets())
            else:
                for chunk in Group._create_chunks(context, goals):
                    for goal in goals:
                        goal_chunk = filter(goal.group.predicate, chunk)
                        if (len(goal_chunk) > 0):
                            context.log.info(('[%s:%s:%s]' % (phase, group_name, goal.name)))
                            execution_phases[phase].add((group_name, goal.name))
                            execute_task(goal.name, tasks_by_goal[goal], goal_chunk)
        if getattr(context.options, 'explain', None):
            for (phase, goals) in execution_phases.items():
                goal_to_task = ', '.join((expand_goal(goal) for goal in goals))
                print ('%s [%s]' % (phase, goal_to_task))
        if locked_by_me:
            context.release_lock()
