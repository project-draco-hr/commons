def execute(self, targets):
    scala_targets = filter(is_scala, reversed(InternalTarget.sort_targets(targets)))
    if scala_targets:
        safe_mkdir(self._classes_dir)
        safe_mkdir(self._depfile_dir)
        with self.context.state('classpath', []) as cp:
            for conf in self._confs:
                cp.insert(0, (conf, self._resources_dir))
                if (not (self._incremental and (not self._flatten))):
                    cp.insert(0, (conf, self._classes_dir))
        if ((not self._flatten) and (len(scala_targets) > 1)):
            upstream_analysis_caches = OrderedDict()
            for target in scala_targets:
                self.execute_single_compilation([target], cp, upstream_analysis_caches)
        else:
            self.execute_single_compilation(scala_targets, cp, {})
        if (self._incremental and (not self._flatten)):
            with self.context.state('classpath', []) as cp:
                for conf in self._confs:
                    cp.insert(0, (conf, self._classes_dir))
        if self.context.products.isrequired('classes'):
            genmap = self.context.products.get('classes')
            for (target, classes_by_source) in self._deps.findclasses(scala_targets).items():
                for (source, classes) in classes_by_source.items():
                    genmap.add(source, self._classes_dir, classes)
                    genmap.add(target, self._classes_dir, classes)
            for target in scala_targets:
                if (is_scalac_plugin(target) and target.classname):
                    basedir = self.write_plugin_info(target)
                    genmap.add(target, basedir, [_PLUGIN_INFO_FILE])
