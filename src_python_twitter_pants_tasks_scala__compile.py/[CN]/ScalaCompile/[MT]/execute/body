def execute(self, targets):
    scala_targets = filter(ScalaCompile._has_scala_sources, targets)
    if (not scala_targets):
        return
    safe_mkdir(self._classes_dir_base)
    safe_mkdir(self._depfiles_base)
    safe_mkdir(self._analysis_files_base)
    with self.context.state('classpath', []) as cp:
        self._add_globally_required_classpath_entries(cp)
        with self.invalidated_with_artifact_cache_check(scala_targets, invalidate_dependents=True, partition_size_hint=self._partition_size_hint) as (invalidation_check, cached_vts):
            self._localize_portable_artifact_files(cached_vts)
            self._compile_all(invalidation_check.invalid_vts_partitioned, scala_targets, cp)
        for target in scala_targets:
            self._post_process(target, cp)
    all_analysis_files = set()
    for target in scala_targets:
        (_, _, analysis_file) = self._output_paths([target])
        if os.path.exists(analysis_file):
            all_analysis_files.add(analysis_file)
    deps_cache = JvmDependencyCache(self.context, scala_targets, all_analysis_files)
    deps_cache.check_undeclared_dependencies()
