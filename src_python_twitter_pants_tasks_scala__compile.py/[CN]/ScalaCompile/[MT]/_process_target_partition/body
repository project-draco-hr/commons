def _process_target_partition(self, vts, cp, upstream_analysis_map):
    'Must run on all target partitions, not just invalid ones.\n\n    May be invoked concurrently on independent target sets.\n\n    Postcondition: The individual targets in vts are up-to-date, as if each were\n                   compiled individually.\n    '
    artifacts = [self._artifact_factory.artifact_for_target(target) for target in vts.targets]
    merged_artifact = self._artifact_factory.merged_artifact(artifacts)
    if (not merged_artifact.sources):
        self.context.log.warn(('Skipping scala compile for targets with no sources:\n  %s' % merged_artifact.targets))
    else:
        current_state = merged_artifact.merge()
        if any([(not vt.valid) for vt in vts.versioned_targets]):
            old_state = current_state
            classpath = [entry for (conf, entry) in cp if (conf in self._confs)]
            self.context.log.info(('Compiling targets %s' % vts.targets))
            if self._zinc_utils.compile(classpath, merged_artifact.sources, merged_artifact.classes_dir, merged_artifact.analysis_file, upstream_analysis_map):
                raise TaskError('Compile failed.')
            write_to_artifact_cache = (self._artifact_cache and self.context.options.write_to_artifact_cache)
            current_state = merged_artifact.split(old_state, portable=write_to_artifact_cache)
            if write_to_artifact_cache:
                self._update_artifact_cache(merged_artifact, vts)
                for (artifact, vt) in zip(artifacts, vts.versioned_targets):
                    assert (artifact.targets == vt.targets)
                    self._update_artifact_cache(artifact, vt)
        if self.context.products.isrequired('classes'):
            self._add_products_to_genmap(merged_artifact, current_state)
    return merged_artifact
