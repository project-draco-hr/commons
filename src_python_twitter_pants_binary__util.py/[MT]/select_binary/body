def select_binary(base_path, version, name, config=None):
    'Selects a binary matching the current os and architecture.\n\n  Raises TaskError if no binary of the given version and name could be found.\n  '
    config = (config or Config.load())
    bootstrap_dir = config.getdefault('pants_bootstrapdir', default=os.path.expanduser('~/.pants.d'))
    baseurl = config.getdefault('pants_support_baseurl')
    timeout_secs = config.getdefault('pants_support_fetch_timeout_secs', type=int, default=30)
    (sysname, _, release, _, machine) = os.uname()
    os_id = _ID_BY_OS[sysname.lower()]
    if os_id:
        middle_path = _PATH_BY_ID[os_id(release, machine)]
        if middle_path:
            binary_path = os.path.join(base_path, *(middle_path + [version, name]))
            bootstrapped_binary_path = os.path.join(bootstrap_dir, binary_path)
            if (not os.path.exists(bootstrapped_binary_path)):
                url = posixpath.join(baseurl, binary_path)
                log.info(('Fetching %s binary from: %s' % (name, url)))
                downloadpath = (bootstrapped_binary_path + '~')
                try:
                    try:
                        with closing(urllib_request.urlopen(url, timeout=timeout_secs)) as binary:
                            with safe_open(downloadpath, 'wb') as bootstrapped_binary:
                                bootstrapped_binary.write(binary.read())
                        os.rename(downloadpath, bootstrapped_binary_path)
                        chmod_plus_x(bootstrapped_binary_path)
                    except (IOError, urllib_error.HTTPError, urllib_error.URLError) as e:
                        raise TaskError(('Failed to fetch binary from %s: %s' % (url, e)))
                finally:
                    safe_delete(downloadpath)
            log.debug(('Selected %s binary bootstrapped to: %s' % (name, bootstrapped_binary_path)))
            return bootstrapped_binary_path
    raise TaskError(('No %s binary found for: %s' % (name, (sysname, release, machine))))
