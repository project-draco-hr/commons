@contextmanager
def invalidated_with_artifact_cache_check(self, targets, only_buildfiles=False, invalidate_dependents=False, partition_size_hint=sys.maxint):
    "Checks targets for invalidation, first checking the artifact cache.\n    Subclasses call this to figure out what to work on.\n\n    targets:               The targets to check for changes.\n    only_buildfiles:       If True, then only the target's BUILD files are checked for changes, not\n                           its sources.\n    invalidate_dependents: If True then any targets depending on changed targets are invalidated.\n    partition_size_hint:   Each VersionedTargetSet in the yielded list will represent targets\n                           containing roughly this number of source files, if possible. Set to\n                           sys.maxint for a single VersionedTargetSet. Set to 0 for one\n                           VersionedTargetSet per target. It is up to the caller to do the right\n                           thing with whatever partitioning it asks for.\n\n    Yields a pair of (invalidation_check, cached_vts) where invalidation_check is an\n    InvalidationCheck object reflecting the (partitioned) targets, and cached_vts is a list of\n    VersionedTargets that were satisfied from the artifact cache.\n\n    If no exceptions are thrown by work in the block, the build cache is updated for the targets.\n    Note: the artifact cache is not updated, that must be done manually.\n    "
    extra_data = []
    extra_data.append(self.invalidate_for())
    for f in self.invalidate_for_files():
        extra_data.append(hash_file(f))
    cache_manager = CacheManager(self._cache_key_generator, self._build_invalidator_dir, invalidate_dependents, extra_data, only_externaldeps=only_buildfiles)
    initial_invalidation_check = cache_manager.check(targets, partition_size_hint)
    partitions_to_check = [vt for vt in initial_invalidation_check.all_vts_partitioned if (not vt.valid)]
    (cached_partitions, uncached_partitions) = self.check_artifact_cache(partitions_to_check)
    uncached_vts = [x.versioned_targets for x in uncached_partitions]
    vts_to_check = [vt for vt in itertools.chain.from_iterable(uncached_vts) if (not vt.valid)]
    (cached_targets, uncached_targets) = self.check_artifact_cache(vts_to_check)
    invalidation_check = InvalidationCheck(initial_invalidation_check.all_vts, uncached_targets, partition_size_hint)
    num_invalid_partitions = len(invalidation_check.invalid_vts_partitioned)
    num_invalid_targets = 0
    num_invalid_sources = 0
    for vt in invalidation_check.invalid_vts:
        if (not vt.valid):
            num_invalid_targets += len(vt.targets)
            num_invalid_sources += vt.cache_key.num_sources
    if (num_invalid_partitions > 0):
        self.context.log.info(('Operating on %d files in %d invalidated targets in %d target partitions' % (num_invalid_sources, num_invalid_targets, num_invalid_partitions)))
    yield invalidation_check
    if (not self.dry_run):
        for vt in invalidation_check.invalid_vts:
            vt.update()
