@contextmanager
def invalidated_with_artifact_cache_check(self, targets, only_buildfiles=False, invalidate_dependents=False, partition_size_hint=sys.maxint):
    "Checks targets for invalidation, first checking the artifact cache.\n    Subclasses call this to figure out what to work on.\n\n    targets: The targets to check for changes.\n\n    only_buildfiles: If True, then only the target's BUILD files are checked for changes, not its sources.\n\n    invalidate_dependents: If True then any targets depending on changed targets are invalidated.\n\n    partition_size_hint: Each VersionedTargetSet in the yielded list will represent targets containing roughly\n    this number of source files, if possible. Set to sys.maxint for a single VersionedTargetSet. Set to 0 for\n    one VersionedTargetSet per target. It is up to the caller to do the right thing with whatever partitioning\n    it asks for.\n\n    Yields a pair of (invalidation_check, cached_vts) where invalidation_check is an InvalidationCheck object\n    reflecting the (partitioned) targets, and cached_vts is a list of VersionedTargets that were satisfied\n    from the artifact cache.\n\n    If no exceptions are thrown by work in the block, the build cache is updated for the targets.\n    Note: the artifact cache is not updated, that must be done manually.\n    "
    extra_data = []
    extra_data.append(self.invalidate_for())
    for f in self.invalidate_for_files():
        sha = hashlib.sha1()
        with open(f, 'rb') as fd:
            sha.update(fd.read())
        extra_data.append(sha.hexdigest())
    cache_manager = CacheManager(self._cache_key_generator, self._build_invalidator_dir, invalidate_dependents, extra_data, only_externaldeps=only_buildfiles)
    unpartitioned_invalidation_check = cache_manager.check(targets)
    cached_vts = []
    if (self._artifact_cache and self.context.options.read_from_artifact_cache):
        for vt in unpartitioned_invalidation_check.invalid_vts:
            if self._artifact_cache.use_cached_files(vt.cache_key):
                self.context.log.info(('Using cached artifacts for %s' % vt.targets))
                vt.update()
                cached_vts.append(vt)
            else:
                self.context.log.info(('No cached artifacts for %s' % vt.targets))
    invalid_vts = list((OrderedSet(unpartitioned_invalidation_check.invalid_vts) - set(cached_vts)))
    partitioned_invalidation_check = InvalidationCheck(unpartitioned_invalidation_check.all_vts, invalid_vts, partition_size_hint)
    num_invalid_partitions = len(partitioned_invalidation_check.invalid_vts_partitioned)
    num_invalid_targets = 0
    num_invalid_sources = 0
    for vt in partitioned_invalidation_check.invalid_vts:
        if (not vt.valid):
            num_invalid_targets += len(vt.targets)
            num_invalid_sources += vt.cache_key.num_sources
    if (num_invalid_partitions > 0):
        self.context.log.info(('Operating on %d files in %d invalidated targets in %d target partitions' % (num_invalid_sources, num_invalid_targets, num_invalid_partitions)))
    yield (partitioned_invalidation_check, cached_vts)
    if (not self.dry_run):
        for vt in partitioned_invalidation_check.invalid_vts:
            vt.update()
