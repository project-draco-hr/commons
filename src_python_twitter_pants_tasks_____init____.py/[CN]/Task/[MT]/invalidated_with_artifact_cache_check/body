@contextmanager
def invalidated_with_artifact_cache_check(self, targets, only_buildfiles=False, invalidate_dependents=False, partition_size_hint=sys.maxint):
    "Checks targets for invalidation, first checking the artifact cache.\n    Subclasses call this to figure out what to work on.\n\n    targets:               The targets to check for changes.\n    only_buildfiles:       If True, then only the target's BUILD files are checked for changes, not\n                           its sources.\n    invalidate_dependents: If True then any targets depending on changed targets are invalidated.\n    partition_size_hint:   Each VersionedTargetSet in the yielded list will represent targets\n                           containing roughly this number of source files, if possible. Set to\n                           sys.maxint for a single VersionedTargetSet. Set to 0 for one\n                           VersionedTargetSet per target. It is up to the caller to do the right\n                           thing with whatever partitioning it asks for.\n\n    Yields a pair of (invalidation_check, cached_vts) where invalidation_check is an\n    InvalidationCheck object reflecting the (partitioned) targets, and cached_vts is a list of\n    VersionedTargets that were satisfied from the artifact cache.\n\n    If no exceptions are thrown by work in the block, the build cache is updated for the targets.\n    Note: the artifact cache is not updated, that must be done manually.\n    "
    extra_data = []
    extra_data.append(self.invalidate_for())
    for f in self.invalidate_for_files():
        extra_data.append(hash_file(f))
    cache_manager = CacheManager(self._cache_key_generator, self._build_invalidator_dir, invalidate_dependents, extra_data, only_externaldeps=only_buildfiles)
    invalidation_check = cache_manager.check(targets, partition_size_hint)
    if (self._artifact_cache and self.context.options.read_from_artifact_cache):
        with self.context.new_workunit('cache'):
            all_cached_targets = []
            partitions_to_check = [vt for vt in invalidation_check.all_vts_partitioned if (not vt.valid)]
            (cached_partitions, uncached_partitions) = self.check_artifact_cache(partitions_to_check)
            for vt in cached_partitions:
                for t in vt.targets:
                    all_cached_targets.append(t)
            vts_to_check = [vt for vt in itertools.chain.from_iterable([x.versioned_targets for x in uncached_partitions]) if (not vt.valid)]
            (cached_targets, uncached_targets) = self.check_artifact_cache(vts_to_check)
            for vt in cached_targets:
                all_cached_targets.append(vt.target)
        if all_cached_targets:
            for t in all_cached_targets:
                self.context.run_tracker.artifact_cache_stats.add_hit('default', t)
            self._report_targets('Using cached artifacts for ', all_cached_targets, '.')
        if uncached_targets:
            for vts in uncached_targets:
                self.context.run_tracker.artifact_cache_stats.add_miss('default', vts.target)
            self._report_targets('No cached artifacts for ', [vt.target for vt in uncached_targets], '.')
        invalidation_check = InvalidationCheck(invalidation_check.all_vts, uncached_targets, partition_size_hint)
    targets = []
    sources = []
    num_invalid_partitions = len(invalidation_check.invalid_vts_partitioned)
    for vt in invalidation_check.invalid_vts_partitioned:
        targets.extend(vt.targets)
        sources.extend(vt.cache_key.sources)
    if len(targets):
        msg_elements = ['Invalidated ', items_to_report_element([t.address.reference() for t in targets], 'target')]
        if (len(sources) > 0):
            msg_elements.append(' containing ')
            msg_elements.append(items_to_report_element(sources, 'source file'))
        if (num_invalid_partitions > 1):
            msg_elements.append((' in %d target partitions' % num_invalid_partitions))
        msg_elements.append('.')
        self.context.log.info(*msg_elements)
    yield invalidation_check
    if (not self.dry_run):
        for vt in invalidation_check.invalid_vts:
            vt.update()
