@contextmanager
def invalidated(self, targets, only_buildfiles=False, invalidate_dependents=False, partition_size_hint=sys.maxint, is_parallel_compile=False):
    "Checks targets for invalidation. Subclasses call this to figure out what to work on.\n\n    targets: The targets to check for changes.\n\n    only_buildfiles: If True, then only the target's BUILD files are checked for changes, not its sources.\n\n    invalidate_dependents: If True then any targets depending on changed targets are invalidated.\n\n    partition_size_hint: Each VersionedTargetSet in the yielded list will represent targets containing roughly\n    this number of source files, if possible. Set to sys.maxint for a single VersionedTargetSet. Set to 0 for\n    one VersionedTargetSet per target. It is up to the caller to do the right thing with whatever partitioning\n    it asks for.\n\n    Yields an InvalidationCheck object reflecting the (partitioned) targets. If no exceptions are\n    thrown by work in the block, the cache is updated for the targets.\n    "
    extra_data = []
    extra_data.append(self.invalidate_for())
    for f in self.invalidate_for_files():
        sha = hashlib.sha1()
        with open(f, 'rb') as fd:
            sha.update(fd.read())
        extra_data.append(sha.hexdigest())
    cache_manager = CacheManager(self._cache_key_generator, self._build_invalidator_dir, invalidate_dependents, extra_data, only_buildfiles, self.context.log)
    if is_parallel_compile:
        invalidation_check = cache_manager.invalidate_and_dagify(targets)
    else:
        invalidation_check = cache_manager.invalidate_and_partition(targets, partition_size_hint)
    num_invalid_targets = 0
    num_invalid_sources = 0
    for vt in invalidation_check.invalid_vts:
        if (not vt.valid):
            num_invalid_targets += len(vt.targets)
            num_invalid_sources += vt.cache_key.num_sources
    self.context.log.info(('Operating on %d files in %d invalidated targets' % (num_invalid_sources, num_invalid_targets)))
    yield invalidation_check
    if (not self.dry_run):
        for vt in invalidation_check.invalid_vts:
            vt.update()
