@contextmanager
def invalidated(self, targets, only_buildfiles=False, invalidate_dependents=False, partition_size_hint=sys.maxint):
    "Checks targets for invalidation, first checking the artifact cache.\n    Subclasses call this to figure out what to work on.\n\n    targets: The targets to check for changes.\n\n    only_buildfiles: If True, then only the target's BUILD files are checked for changes,\n                     not its sources.\n\n    invalidate_dependents: If True then any targets depending on changed targets are invalidated.\n\n    partition_size_hint: Each VersionedTargetSet in the yielded list will represent targets\n                         containing roughly this number of source files, if possible. Set to\n                         sys.maxint for a single VersionedTargetSet. Set to 0 for one\n                         VersionedTargetSet per target. It is up to the caller to do the right\n                         thing with whatever partitioning it asks for.\n\n    Yields an InvalidationCheck object reflecting the (partitioned) targets.\n\n    If no exceptions are thrown by work in the block, the build cache is updated for the targets.\n    Note: the artifact cache is not updated, that must be done manually.\n    "
    extra_data = []
    extra_data.append(self.invalidate_for())
    for f in self.invalidate_for_files():
        sha = hashlib.sha1()
        with open(f, 'rb') as fd:
            sha.update(fd.read())
        extra_data.append(sha.hexdigest())
    cache_manager = CacheManager(self._cache_key_generator, self._build_invalidator_dir, invalidate_dependents, extra_data, only_externaldeps=only_buildfiles)
    initial_invalidation_check = cache_manager.check(targets, partition_size_hint)
    partitions_to_check = [vt for vt in initial_invalidation_check.all_vts_partitioned if (not vt.valid)]
    (cached_partitions, uncached_partitions) = self.check_artifact_cache(partitions_to_check)
    vts_to_check = [vt for vt in itertools.chain.from_iterable([x.versioned_targets for x in uncached_partitions]) if (not vt.valid)]
    (cached_targets, uncached_targets) = self.check_artifact_cache(vts_to_check)
    invalidation_check = InvalidationCheck(initial_invalidation_check.all_vts, uncached_targets, partition_size_hint)
    num_invalid_partitions = len(invalidation_check.invalid_vts_partitioned)
    num_invalid_targets = 0
    num_invalid_sources = 0
    for vt in invalidation_check.invalid_vts:
        if (not vt.valid):
            num_invalid_targets += len(vt.targets)
            num_invalid_sources += vt.cache_key.num_sources
    if (num_invalid_partitions > 0):
        self.context.log.info(('Operating on %d files in %d invalidated targets in %d target partitions' % (num_invalid_sources, num_invalid_targets, num_invalid_partitions)))
    yield invalidation_check
    if (not self.dry_run):
        for vt in invalidation_check.invalid_vts:
            vt.update()
